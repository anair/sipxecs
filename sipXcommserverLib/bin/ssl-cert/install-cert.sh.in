#!@BASH@
##
## install-cert.sh
##
##  Copyright (C) 2007 Pingtel Corp., certain elements licensed under a Contributor Agreement.  
##  Contributors retain copyright to elements licensed under a Contributor Agreement.
##  Licensed to the User under the LGPL license.
##

: ${REMOTE_SSL_CERT_SCRIPT:=$0}

remote_send() {
  remoteServer=$1
  shift
  echo "Installing certificate information on remote server $remoteServer..."
  # send tar on stdin to the remote copy of this script, only remote server, over ssh
  # thusly, remote_receive will be invoked on remote server
  tar -c $@ | ssh $remoteServer ${REMOTE_SSL_CERT_SCRIPT} --remote-receive $remoteServer

  exit
}

remote_receive() {
  echo "Receiving certificate information from remote server..."
  # don't put into /tmp/dir incase it makes it available to users it shouldn't
  # root home directory is better
  tempDir=install-cert-remote-receive.tmp

  test -d $tempDir || mkdir $tempDir
  pushd $tempDir

  # extract files on stdin from remote_send command over ssh
  tar -vx

  # recursive run to install cert normally on remote
  $0 $1

  popd
  rm -r $tempDir
  
  exit
}


Action=INSTALL
Basename=""

while [ $# -ne 0 ]
do
    case ${1} in
        -r|--remote)
	    Action=REMOTE_SEND
            ;;

        ## Internal command
        --remote-receive)
	    Action=REMOTE_RECEIVE
            ;;
        ##
        ## handle an unknown switch
        ##
        -*)
            Action=USAGE
            break
            ;;

        # positional arguments
        *)
            if [ -z "${Basename}" ]
            then
                Basename=${1}
            else
                echo "Too many arguments supplied: $@" 1>&2
                Action=USAGE
                break
            fi
            ;;
    esac           

    shift # always consume 1
done

if [ -z "${Basename}" ]
then
    Basename=`hostname --fqdn`
fi

if [ "${Action}" = "REMOTE_RECEIVE" ]
then
  remote_receive "${Basename}"
  exit
fi

if ! [ -f "${Basename}.crt" -a -f "${Basename}.key" ]
then
    cat <<EOF 1>&2
! Certificate and key not found for ${Basename}
  ${Basename}.crt
  ${Basename}.key

EOF
    Action=USAGE
fi

if [ "${Action}" = "USAGE" ]
then
    cat <<EOF
Usage:
   install-cert.sh [--remote] [ <server-name> ]

   The server-name specifies the base name of the .key and .crt files
   generated by the gen-ssl-keys.sh script.  If not specified, it defaults
   to the fully qualified host name of the system.

   --remote will install the .key, .crt and CA certificate on the remote
   machine <server-name>.  The remote machine has to have sipxpbx installed
   of the same major version.

   The certificate is examined to find the issuer name; if a CA certificate
   is found in the same directory with that name (with a '.crt' suffix),
   than that certificate is installed as a trusted authority.

EOF
    exit 1
fi

caName=`@OPENSSL@ x509 -in "${Basename}.crt" -issuer -nameopt RFC2253,multiline -noout | perl -ne 'use English; m/^ +commonName += / && print $POSTMATCH'`

if [ -n "${caName}" -a -f "${caName}.crt" ]
    then
    AuthoritySwitch="--authority"
    AuthorityTarget=${caName}.crt
else
    AuthoritySwitch=""
fi

if [ "${Action}" = "REMOTE_SEND" ]
then
  remote_send "${Basename}" "${Basename}.crt" "${Basename}.key" "${caName}.crt"
  exit
fi


echo "Checking the '${Basename}' certificate"

if @bindir@/ssl-cert/check-cert.sh ${AuthoritySwitch} "${AuthorityTarget}" "$Basename.crt"
then

    if [ ! -d @SIPX_CONFDIR@/ssl ]
    then
        mkdir               @SIPX_CONFDIR@/ssl || exit 1
        chown @SIPXPBXUSER@ @SIPX_CONFDIR@/ssl || exit 1
        chmod 0700          @SIPX_CONFDIR@/ssl || exit 1
    fi

    if [ -n "${caName}" -a -f "${caName}.crt" ]
    then
        # create the sipX authorities store directory
        if [ ! -d @SIPX_CONFDIR@/ssl/authorities ]
        then
            mkdir               @SIPX_CONFDIR@/ssl/authorities || exit 1
            chown @SIPXPBXUSER@ @SIPX_CONFDIR@/ssl/authorities || exit 1
            chmod 0700          @SIPX_CONFDIR@/ssl/authorities || exit 1
        fi
        
        echo "Installing '${caName}.crt' certificate as a trusted CA"
        cp -v "${caName}.crt" "@SIPX_CONFDIR@/ssl/authorities/${caName}.crt" || exit 1
        chown @SIPXPBXUSER@   "@SIPX_CONFDIR@/ssl/authorities/${caName}.crt" || exit 1
        chmod 0644            "@SIPX_CONFDIR@/ssl/authorities/${caName}.crt" || exit 1

        # regenerate the hash symlinks for the certificate store
        @bindir@/ssl-cert/ca_rehash 
    fi

    echo "Installing the '${Basename}' certificate"
    cp -v "$Basename.crt" @SIPX_CONFDIR@/ssl/ssl.crt || exit 1
    chown @SIPXPBXUSER@   @SIPX_CONFDIR@/ssl/ssl.crt || exit 1
    chmod 0600            @SIPX_CONFDIR@/ssl/ssl.crt || exit 1

    echo "Installing the '${Basename}' private key"
    cp -v "$Basename.key" @SIPX_CONFDIR@/ssl/ssl.key || exit 1
    chown @SIPXPBXUSER@   @SIPX_CONFDIR@/ssl/ssl.key || exit 1
    chmod 0600            @SIPX_CONFDIR@/ssl/ssl.key || exit 1

    echo "Checking the installed certificate"
    if @bindir@/ssl-cert/check-cert.sh @SIPX_CONFDIR@/ssl/ssl.crt
    then
        cat <<EOF

  Your sipX SSL security is now configured.

EOF

    cert_expires=`@OPENSSL@ x509 -in "${Basename}.crt" -noout -enddate | sed 's/notAfter=//'`

    cat <<EOF

  Your server certificate will expire ${cert_expires}. 

EOF

    else
        echo "Post-install check failed." 1>&2
        exit 1;
    fi

else
    cat <<EOF 1>&2

! Check failed - certificate and key not installed.
EOF

    if [ -n "${caName}" ]
    then
        cat <<EOF 1>&2

  You may need to obtain the root certificate for your CA ('${caName}').
  If you get a copy of the root certificate, put it in this directory, named
  '${caName}.crt' and rerun this command.

EOF
    fi
    exit 1;
fi
