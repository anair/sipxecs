#!@BASH@
##
## install-cert.sh
##
##  Copyright (C) 2007 Pingtel Corp., certain elements licensed under a Contributor Agreement.  
##  Contributors retain copyright to elements licensed under a Contributor Agreement.
##  Licensed to the User under the LGPL license.
##

: ${REMOTE_SSL_CERT_SCRIPT:=$0}

remote_send() {
  remoteServer=$1
  shift
  echo "Installing certificate information on remote server $remoteServer..."
  # send tar on stdin to the remote copy of this script, only remote server, over ssh
  # thusly, remote_receive will be invoked on remote server
  tar -c $@ | ssh $remoteServer ${REMOTE_SSL_CERT_SCRIPT} --remote-receive $remoteServer

  exit
}

remote_receive() {
  echo "Receiving certificate information from remote server..."
  # don't put into /tmp/dir incase it makes it available to users it shouldn't
  # root home directory is better
  tempDir=install-cert-remote-receive.tmp

  test -d $tempDir || mkdir $tempDir
  pushd $tempDir

  # extract files on stdin from remote_send command over ssh
  tar -vx

  # recursive run to install cert normally on remote
  $0 $1

  popd
  rm -r $tempDir
  
  exit
}

CurrentWorkDir=`pwd`
WorkDir=${CurrentWorkDir}

InstallDir="@SIPX_CONFDIR@"
openssl="@OPENSSL@"
sipXuser="@SIPXPBXUSER@"

Action=INSTALL
Basename=""

certOk=0
certsInstalled=0

while [ $# -ne 0 ]
do
    case ${1} in
        -r|--remote)
	    Action=REMOTE_SEND
            ;;

        ## Internal command
        --remote-receive)
	    Action=REMOTE_RECEIVE
            ;;

        -wd|--workdir)
            ##
            ## Set the directory where database files and outputs should be
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <working-directory> with ${1}" 1>&2
                Action=USAGE
                break
            else
                WorkDir=${2}
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        ##
        ## handle an unknown switch
        ##
        -*)
            Action=USAGE
            break
            ;;

        # positional arguments
        *)
            if [ -z "${Basename}" ]
            then
                Basename=${1}
            else
                echo "Too many arguments supplied: $@" 1>&2
                Action=USAGE
                break
            fi
            ;;
    esac           

    shift # always consume 1
done

if [ -z "${Basename}" ]
then
    Basename=`hostname --fqdn`
else
    # if they gave the full file name, strip the suffix off
    case "${Basename}" in
        *.crt)
            Basename=`basename "${Basename}" .crt`
            ;;
        *.p12)
            Basename=`basename "${Basename}" .p12`
            ;;
        *.key)
            Basename=`basename "${Basename}" .key`
            ;;
    esac

    case "${Basename}" in
        *-sip)
            installQualifier="-sip"
            ;;
        *-web)
            installQualifier="-web"
            ;;
        *)
            installQualifier=""
            ;;
    esac


fi

if [ "${Action}" = "REMOTE_RECEIVE" ]
then
  remote_receive "${Basename}"
  exit
fi

if test "${CurrentWorkDir}" != "${WorkDir}"
then
    cd "${WorkDir}" > /dev/null || exit 1
fi

if ! [ -f "${Basename}.crt" -a -f "${Basename}.key" ]
then
    cat <<EOF 1>&2
! Certificate and key not found for ${Basename}
  ${Basename}.crt
  ${Basename}.key

EOF
    Action=USAGE
fi

if [ "${Action}" = "USAGE" ]
then
    cat <<EOF
Usage:
   install-cert.sh [ {-wd|--workdir} <working-directory> ]
                   [ <server-name> ]

   The server-name specifies the base name of the .key and .crt files
   generated by the gen-ssl-keys.sh script.  If not specified, it defaults
   to the fully qualified host name of the current system.

   --workdir    Specifies a directory where all files should be stored:
                defaults to the current directory.  If specified, then
                other names may be relative to this directory.

   install-cert.sh [ {-wd|--workdir} <working-directory> ]
                   --remote <server-name>

   Installs the .key, .crt and CA certificate on the remote system <server-name>.  
   The remote system must have sipxpbx installed of the same major version.

   The certificate is examined to find the issuer name; if a CA certificate
   is found in the same directory with that name (with a '.crt' suffix),
   than that certificate is installed as a trusted authority.

EOF
    exit 1
fi

caName=`${openssl} x509 -in "${Basename}.crt" -issuer -nameopt RFC2253,multiline -noout \
    | perl -ne 'use English; m/^ +commonName += / && print $POSTMATCH'`

if [ -n "${caName}" -a -f "${caName}.crt" ]
    then
    AuthoritySwitch="--authority"
    AuthorityTarget=${caName}.crt
else
    AuthoritySwitch=""
fi

if [ "${Action}" = "REMOTE_SEND" ]
then
  remote_send "${Basename}" "${Basename}.crt" "${Basename}.key" "${caName}.crt"
  exit
fi


echo "Checking the '${Basename}' certificate"

if @bindir@/ssl-cert/check-cert.sh ${AuthoritySwitch} "${AuthorityTarget}" "$Basename.crt"
then

    if [ ! -d ${InstallDir}/ssl ]
    then
        mkdir               ${InstallDir}/ssl || exit 1
        chown ${sipXuser}   ${InstallDir}/ssl || exit 1
        chmod 0700          ${InstallDir}/ssl || exit 1
    fi

    if [ -n "${caName}" -a -f "${caName}.crt" ]
    then
        # create the sipX authorities store directory
        if [ ! -d ${InstallDir}/ssl/authorities ]
        then
            mkdir               ${InstallDir}/ssl/authorities || exit 1
            chown ${sipXuser}   ${InstallDir}/ssl/authorities || exit 1
            chmod 0700          ${InstallDir}/ssl/authorities || exit 1
        fi
        
        echo "Installing '${caName}.crt' certificate as a trusted CA"
        cp -v "${caName}.crt" "${InstallDir}/ssl/authorities/${caName}.crt" || exit 1
        chown ${sipXuser}     "${InstallDir}/ssl/authorities/${caName}.crt" || exit 1
        chmod 0644            "${InstallDir}/ssl/authorities/${caName}.crt" || exit 1

        # regenerate the hash symlinks for the certificate store
        @bindir@/ssl-cert/ca_rehash 
    fi

    if [ -r "${Basename}.crt" -a -r "${Basename}.key" ]
    then
        echo "Installing the '${Basename}' certificate (pem format)"
        cp -v "$Basename.crt" "${InstallDir}/ssl/ssl${installQualifier}.crt" || exit 1
        chown ${sipXuser}     "${InstallDir}/ssl/ssl${installQualifier}.crt" || exit 1
        chmod 0600            "${InstallDir}/ssl/ssl${installQualifier}.crt" || exit 1

        echo "Installing the '${Basename}' private key"
        cp -v "$Basename.key" "${InstallDir}/ssl/ssl${installQualifier}.key" || exit 1
        chown ${sipXuser}     "${InstallDir}/ssl/ssl${installQualifier}.key" || exit 1
        chmod 0600            "${InstallDir}/ssl/ssl${installQualifier}.key" || exit 1

        certsInstalled+=1

        echo "Checking the installed certificate"
        @bindir@/ssl-cert/check-cert.sh "${InstallDir}/ssl/ssl${installQualifier}.crt"
        certOk+=$?
    fi

    if [ -r "${Basename}.p12" ]
    then
        echo "Installing the '${Basename}' certificate (pkcs12 format)"
        cp -v "$Basename.crt" "${InstallDir}/ssl/ssl${installQualifier}.p12" || exit 1
        chown ${sipXuser}     "${InstallDir}/ssl/ssl${installQualifier}.p12" || exit 1
        chmod 0600            "${InstallDir}/ssl/ssl${installQualifier}.p12" || exit 1

        certsInstalled+=1
    fi

    if [ ${certOk} -eq 0 -a ${certsInstalled} -gt 0 ]
    then
        cat <<EOF

  Your TLS/SSL security is now configured.

EOF

    cert_expires=`${openssl} x509 -in "${Basename}.crt" -noout -enddate | sed 's/notAfter=//'`

    cat <<EOF

  Your server certificate will expire ${cert_expires}. 

EOF

    else
        echo "Post-install check failed." 1>&2
        exit 1;
    fi

else
    cat <<EOF 1>&2

! Check failed - certificate and key not installed.
EOF

    if [ -n "${caName}" ]
    then
        cat <<EOF 1>&2

  You may need to obtain the root certificate for your CA ('${caName}').
  If you get a copy of the root certificate, put it in this directory, named
  '${caName}.crt' and rerun this command.

EOF
    fi
    exit 1;
fi
