#!@BASH@
##
##  gen-ssl-keys.sh - generate SSL key and certificate files.
##
##  Copyright (C) 2007 Pingtel Corp., certain elements licensed under a Contributor Agreement.
##  Contributors retain copyright to elements licensed under a Contributor Agreement.
##  Licensed to the User under the LGPL license.
##
##  Originally derived from:
##  CCA -- Trivial Client CA management for testing purposes
##  Copyright (c) 1998-2001 Ralf S. Engelschall, All Rights Reserved.
##

################################################################################
#### This script acts in concert with install-cert.sh to manage TLS/SSL
#### certificates.  
####
#### The rold of gen-ssl-keys.sh is to collect the information required and
#### generate the private-key/certificate pairs for a private certificate 
#### authority and all certificates issued by that authority.  This private CA
#### is maintained in WorkDir, which defaults to the current working directory
#### or may be set using the --workdir|-w option.  
####
#### The install-cert.sh script is responsible for moving the appropriate set
#### of files from this directory to the configuration directories where the
#### software expects to find it.
####
#### The WorkDir contains:
####   SSL_DEFAULTS - values common to all certs issued by the private CA
####   rnd_seed     - pseudo-random number generator seed value
####   
####   For the CA:
####     <ca-name>.csr   - the inputs used to generate the .crt file; this can be used
####                       later to regenerate the .crt with new expiration dates.
####     <ca-name>.ser   - a serial number (incremented each time a certificate/key pair is made)
####     <ca-name>.crt   - the public certificate for the CA
####     <ca-name>.key   - the private key for the CA
####                          NOTE: the security of _everything_ that uses the certificates
####                                and keys generated by this script is dependant on the
####                                privacy of this value.  Treat with great care.
####     authorities.jks - a Java Trust Store file that contains the CA certificate
####
####
####   For each host:
####     <host-name>[-{sip,web}].csr   - the inputs used to generate the .crt file; 
####                                     this can be used later to regenerate the .crt
####                                     with new expiration dates.
####     <host-name>[-{sip,web}].crt   - the public certificate for the host
####     <host-name>[-{sip,web}].key   - the private key for the CA
####                                     NOTE: the security of the host that uses the certificates
####                                           and keys generated by this script is dependant on the
####                                           privacy of this value.  Treat with great care.
####     <host-name>[-{sip,web}].p12   - a PKCS12 format file that combines:
####                                       the host public certificate
####                                       the host private key
####                                       the CA public certificate
####     <host-name>[-{sip,web}].keystore - a Java Trust Store file that combines:
####                                       the host public certificate
####                                       the host private key
####
####         In the host-name files above, the '-sip' or '-web' are present when the
####         --sip-only or --web-only command line options were specified.  These
####         options cause the generated certificate to be created with only those
####         values appropriate to the more limited purpose requested.  If neither 
####         option is specified, the resulting certificate is created with options
####         appropriate to both purposes.
################################################################################

myName=`basename $0`
myDir=`dirname $0`
# default Certificate Authority Expiration is 10 years
AuthorityDays=3650
# default server expiration is 3 years
CertDays=1095

CAkeyBits=2048
ServerKeyBits=1024

RestrictionType=SIP_AND_WEB
RestrictedCert=UNRESTRICTED
Restrictions=""
restrictionName=""

# default action - generate self-signed CA certificate and host certificate
Action=DO_ALL
AutoDefault=OFF

#   external tools
openssl="@OPENSSL@"

caName=""

configDir="@SIPX_CONFDIR@"

# if there is a file of saved default answers for the questions, read them
DefaultDefaults=SSL_DEFAULTS
Defaults=""

DefaultServer=`hostname --fqdn`
SipDomainName=""
OrganizationName=""

defaultEmail=${USER}@`hostname --domain`

CurrentWorkDir=`pwd`
WorkDir=${CurrentWorkDir}


JavaCmd=`@SIPX_BINDIR@/sipx-config --java`
KeyTool=`@SIPX_BINDIR@/sipx-config --java keytool`
SipXCommonsDir=@SIPX_JAVADIR@/sipXcommons/
#This is the java keystore password. It is referenced
#in various startup scripts. Do not change.
Password="changeit"
TrustStore="authorities.jks"



############################################################################################
## The variables that can be set from Defaults:
## Name                     Description                             Default Value
##
## countryName              Country Name (2 letter code)
## stateOrProvinceName      State or Province Name (full name)
## localityName             Locality Name (eg, city)
## organizationName         Organization Name (eg, company)
## organizationalUnitName   Organization Unit Name (eg, section)     VoIP Services
## caName                   CA Common Name        ${organizationName} VoIP Certificate Authority
## caEmail                  Email Contact Address for CA             ${USER}@`hostname --domain`
## sipDomainName            SIP domain name                          `hostname --domain`
## serverName               Full DNS name for the server             `hostname --fqdn`
## server Server            Common Name (name for Server)            `hostname --fqdn`
## serverEmail              Email Contact Address for Server         ${caEmail}
############################################################################################

showUsage()
{
    cat <<USAGE

    Generate and display SSL keys and certificates; with it
    you can:

    - Display the contents of a certificate file:

      get-ssl-keys.sh --show-cert <certificate-file>

    - Display the contents of a certificate request file:

      get-ssl-keys.sh --show-csr <certificate-request-file>

    - Create a self-signed certificate for a single system:

      gen-ssl-keys.sh [ {-s|--server} <server-name> ]
                      [ {-D|--domain} <sip-domain-name> ]
                      [ <certificate-options> ]
                      [ <generator-options> ]

    - Create a private key and certificate request for use
      with a public or private certificate authority:

      gen-ssl-keys.sh --csr
                      [ <certificate-options> ]
                      [ <generator-options> ]

    - Create a private self-signed authority certificate you can
      use to sign certificates for multiple systems:

      gen-ssl-keys.sh --new-ca
                      [ <generator-options> ]

    - Create a certificate for your server signed by your own
      authority certificate:

      gen-ssl-keys.sh --sign <csr-file>
                      [ {-r|--restricted} ]
                      [ --ca <ca-name> ]
                      [ --ca-key <keyfile> ]
                      [ <certificate-options> ]
                      [ <generator-options> ]

    - Convert an existing CA certificate to a Java Truststore named authorities.jks

      gen-ssl-keys.sh --convert-ca2trust <ca-name>
                      [ <generator-options> ]
                  
    - Convert an existing host certificate to a Java Keystore
      The files "<host>.crt" and <host>.key" are converted to "<host>.jks"
      (as a side effect, this also produces "<host>.p12")

      gen-ssl-keys.sh --convert-crt2jks <host>
                      [ <generator-options> ]

    In each of the above, the <certificate-options> are:

      --web-only  requests a certificate with only subject names
                  needed by http.  If this is used, the resulting
                  file names will have '-web' appended to the
                  server name.

      --sip-only  requests a certificate with only subject names
                  needed by sip.  If this is used, the resulting
                  file names will have '-sip' appended to the
                  server name.

      (if neither of the above are specified, subject names used
       by both protocols are included)

      --restricted adds an indication to the certificate that its use
                   is restricted to web client, web server, and/or
                   sip server usage (depending on whether or the
                   --web-only or --sip-only options were used).

    The <generator-options> are:

         {-wd|--workdir} <working-directory>

                 Specifies a directory where all files should be stored:
                 defaults to the current directory.  If specified, then
                 any relative path name given in an argument is assumed
                 to be relative to this directory.

         {-p|--parameters} <parameter-file>

                 Specifies a file from which default answers should be read:
                 defaults to <working-directory>/${DefaultDefaults}

         {-d|--defaults}

                 Forces the default values to be used with no
                 interactive prompting.

    See @SIPX_DOCDIR@/INSTALL.ssl.{txt,html} for details on usage.

    Derived from cca.sh:
    Copyright (c) 1998-2001 Ralf S. Engelschall, All Rights Reserved.

USAGE
}

### Prompts for a value for variable,
###    the default is the current value if variable is set, and the default argument if not
###    the answer is stored in the ${Defaults} file unless NOSTORE is passed.as the fourth arg.
askfor () # variable, prompt, default, storeflag
{
    local var="$1"
    local prompt="$2"
    local default="${!var:-$3}"
    local store=$4
    local value=""

    if [ "${AutoDefault}" = "AUTODEFAULT" ]
    then
        value="${default}"
        if test -z "${value}"
        then
            echo "Can not default ${prompt}" 1>&2
            echo "   Set parameter '${var}' in ${Defaults}" 1>&2
            exit 1
        fi
        echo "  ${prompt}: ${default}"
    else
        until test -n "${value}"
        do
            echo -n "${prompt} [${default}] : "
            read value

            if test -z "${value}"
            then
                value="${default}"
            fi
        done
    fi

    eval "${var}=\"${value}\""

    if test "${store}" != "NOSTORE" && ! grep -q -e "^${var}=" "${Defaults}" 2> /dev/null
    then
        cat >> "${Defaults}" <<EOF
${var}="${value}"
EOF
    fi
}

seedRand()
{
    # ensures that randomFile has been set up and has new bits in it
    if [ ! -f "${randomFile}" ]
    then
        # find some random files
        # (do not use /dev/random here, because this device
        # doesn't work as expected on all platforms)
        randfiles=''
        numrandfiles=0
        for file in /var/log/messages /var/adm/messages /tmp/* /etc/resolv.conf; do
            #  make sure file is readable and not empty
            if [ -r ${file} -a -s ${file} ]; then
                if [ ".${randfiles}" = . ]; then
                    randfiles="${file}"
                else
                    randfiles="${randfiles}:${file}"
                fi
                numrandfiles=$((${numrandfiles} + 1))
                test ${numrandfiles} -ge 6 && break
            fi
        done
        ${openssl} rand \
            -rand "${randfiles}" \
            -out "${randomFile}" \
            ${CAkeyBits}
    else
        ${openssl} rand \
            -rand "${randomFile}" \
            -out "${randomFile}" \
            ${CAkeyBits}
    fi
}

################################################################
#### GET FUNCTIONS
#### These prompt for values from the user,
####  but perform no actual computations.
################################################################

## Get the certificate values for where the subject is.
getLocality()
{
    askfor countryName            "Country Name (2 letter code)" ""
    askfor stateOrProvinceName    "State or Province Name (full name)" ""
    askfor localityName           "Locality Name (eg, city)" ""
    askfor organizationName       "Organization Name (eg, company)" "${OrganizationName}"
    askfor organizationalUnitName "Organization Unit Name (eg, section)" "VoIP Services"
}

# Get the CA name and email address
getCAInfo()
{
    cat <<EOF

______________________________________________________________________
Identifying information for your private Certificate Authority (CA)

EOF

    askfor caName   "CA Common Name" "${organizationName} VoIP Certificate Authority"
    askfor caEmail  "Email Contact Address for CA (name@example.org)" "${defaultEmail}"
}

getRestrictions()
{
    if test ${RestrictedCert} = RESTRICTED
    then
        case ${RestrictionType} in
            WEB_ONLY)
                Restrictions="extendedKeyUsage=serverAuth,clientAuth"
                ;;

            SIP_ONLY)
                Restrictions="extendedKeyUsage=1.3.6.1.5.5.7.3.20"
                ;;

            SIP_AND_WEB)
                Restrictions="extendedKeyUsage=serverAuth,clientAuth,1.3.6.1.5.5.7.3.20"
                ;;
        esac
    else
        Restrictions=""
    fi

    case ${RestrictionType} in
        WEB_ONLY)
            restrictionName="-web"
            ;;

        SIP_ONLY)
            restrictionName="-sip"
            ;;

        SIP_AND_WEB)
            restrictionName=""
            ;;
    esac
}

# Get subjects
getSubjects()
{
    case ${RestrictionType} in
        WEB_ONLY)
            getServerName
            Subjects="DNS:${serverName}"
            ;;

        SIP_ONLY|SIP_AND_WEB)
            getServerName
            getSipName
            Subjects="URI:sip:${sipDomainName},DNS:${serverName}"
            ;;
    esac

    getRestrictions
    askfor serverEmail "Email Contact Address (name@example.org)" "${caEmail}" NOSTORE

}

# Get the server-specific information
# - ensures that server name is not the same as ca name, which is not allowed by validation
getServerName()
{
    cat <<EOF

______________________________________________________________________
Identifying information for the server:

EOF

    askfor serverName        "Full DNS name for the server" "${ServerName:-${DefaultServer}}" NOSTORE
    while test $"{caName}" = "${serverName}"
    do
        echo "" 1>&2
        echo "Error: The Server name must be different than the CA name." 1>&2
        serverName=""
        askfor serverName "Server Common Name (DNS name for Server)" `hostname --fqdn` NOSTORE
    done
}

getSipName()
{
    cat <<EOF

______________________________________________________________________
Identifying information for the SIP domain:

EOF

    if [ -n "${SipDomainName}" ]
    then
        sipDomainName="${SipDomainName}"
    fi
    askfor sipDomainName "SIP domain name" `hostname --domain`

     while test "${caName}" = "${sipDomainName}"
    do
        echo "" 1>&2
        echo "Error: The SIP domain name must be different than the CA name." 1>&2
        sipDomainName=""
        askfor sipDomainName "SIP domain name" `hostname --domain`
    done
}

################################################################
#### GENERATOR FUNCTIONS
#### These perform calculations and create files,
#### They never prompt for anything, so that they can be combined
#### by different action functions.
################################################################

## Generate a self-signed CA certificate
genCA()
{
    cat <<EOF

Generating private Certificate Authority (CA)
______________________________________________________________________

EOF
    if test -f "${caName}".key -a -f "${caName}".crt
    then
        cat <<EOF

  Certificate files for CA '${caName}' already exist
    ${caName}.key
    ${caName}.crt

  Using the existing files.

  To generate new CA certificate, delete the existing files and re-execute.
______________________________________________________________________
EOF
        return 0
    fi

    cat <<EOF

        Generating RSA private key for CA (${CAkeyBits} bit)

EOF
    ${openssl} genrsa \
        -rand ${randomFile} \
        -out "${caName}.key" \
        ${CAkeyBits}

    if [ $? -ne 0 ]; then
        echo "${myName}:Error: Failed to generate RSA private key" 1>&2
        exit 1
    fi
    chmod go= "${caName}".key

    echo "______________________________________________________________________"
    echo ""
    echo "        Generating X.509 certificate signing request for CA"

    cat >"${caName}"_csr.cfg <<EOT
[ req ]
default_bits                    = ${CAkeyBits}
distinguished_name              = req_DN
prompt                          = no
RANDFILE                        = ${randomFile}
[ req_DN ]
countryName                     = ${countryName}
stateOrProvinceName             = ${stateOrProvinceName}
localityName                    = ${localityName}
0.organizationName              = ${organizationName}
organizationalUnitName          = ${organizationalUnitName}
commonName                      = ${caName}
emailAddress                    = ${caEmail}
EOT

    ${openssl} req \
        -config "${caName}_csr.cfg" \
        -new \
        -key "${caName}.key" \
        -sha1 \
        -out "${caName}.csr"

    if [ $? -ne 0 ]; then
        echo "${myName}:Error: Failed to generate certificate signing request" 1>&2
        exit 1
    fi



    echo "______________________________________________________________________"
    echo ""
    echo "        Generating X.509 certificate for CA signed by itself"

    # use minutes in the epoch as the initial serial number
    # to prevent clashes when the admin wipes out the system and starts over.
    startSerial=$((`date +%s` / 60 ))

    cat >"${caName}_crt.cfg" <<EOT
[ x509v3 ]
basicConstraints = CA:true,pathlen:0
nsComment        = "${myName} generated custom CA certificate"
nsCertType       = sslCA
EOT

    ${openssl} x509 \
        -req \
        -signkey "${caName}.key" \
        -set_serial ${startSerial} \
        -extfile "${caName}_crt.cfg" \
        -extensions x509v3 \
        -days ${AuthorityDays} \
        -sha1 \
        -in "${caName}.csr" \
        -out "${caName}.crt" \
        -text \
        -certopt no_pubkey,no_sigdump

    if [ $? -ne 0 ]; then
        echo "${myName}:Error: Failed to generate self-signed CA certificate" 1>&2
        exit 1
    fi
    printf "%08x" $((${startSerial} + 1)) > "${caName}.ser"

    echo "______________________________________________________________________"
    echo ""
    echo -n "Verify..."
    ${openssl} verify "${caName}.crt"

    if [ $? -eq 0 ]; then
        echo "CA certificate OK" 1>&2
        rm -f "${caName}_csr.cfg"  "${caName}_crt.cfg"
    else
        echo "${myName}:Error: Failed to verify resulting X.509 certificate" 1>&2
        exit 1
    fi

}

## Generate a Certificate Signing Request
genServerCSR()
{
    echo ""
    echo "Generating server certificate request [${serverName}]"
    echo "______________________________________________________________________"
    echo ""
    echo "        Generating RSA private key for server (${ServerKeyBits} bit)"

    ${openssl} genrsa \
        -rand "${randomFile}" \
        -out "${serverName}${restrictionName}.key" \
        ${ServerKeyBits}

    if [ $? -ne 0 ]; then
        echo "${myName}:Error: Failed to generate RSA private key" 1>&2
        exit 1
    fi
    chmod o=,g=r "${serverName}${restrictionName}.key"

    echo "______________________________________________________________________"
    echo ""
    echo "        Generating X.509 certificate signing request for '${serverName}'"
    cat >"${serverName}${restrictionName}_csr.cfg" <<EOT
[ req ]
default_bits           = ${ServerKeyBits}
distinguished_name     = req_DN
prompt                 = no
RANDFILE               = ${randomFile}
[ req_DN ]
countryName            = ${countryName}
stateOrProvinceName    = ${stateOrProvinceName}
localityName           = ${localityName}
0.organizationName     = ${organizationName}
organizationalUnitName = ${organizationalUnitName}
commonName             = ${serverName}
emailAddress           = ${serverEmail}
[ extend_req ]
basicConstraints       = CA:FALSE
subjectAltName         = ${Subjects}
subjectKeyIdentifier   = hash
${Restrictions}
EOT

    ${openssl} req \
        -config "${serverName}${restrictionName}_csr.cfg" \
        -new \
        -sha1 \
        -key "${serverName}${restrictionName}.key" \
        -reqexts extend_req \
        -out "${serverName}${restrictionName}.csr" \
        -days ${CertDays}

    if [ $? -ne 0 ]; then
        echo "${myName}:Error: Failed to generate certificate signing request" 1>&2
        exit 1
    else
        rm -f "${serverName}${restrictionName}_csr.cfg"
    fi
}



## Sign a server certificate
signServerCertificate()
{
    echo "______________________________________________________________________"
    echo ""
    echo "        Generating X.509 certificate signed by ${caName}"

    cat > "${serverName}${restrictionName}_crt.cfg" <<EOT
[ x509v3 ]
basicConstraints = CA:false,pathlen:0
[ extend_cert ]
basicConstraints       = CA:FALSE
subjectAltName         = ${Subjects}
subjectKeyIdentifier   = hash
${Restrictions}
EOT

    ${openssl} x509 \
        -req \
        -CA "${caName}.crt" \
        -CAkey "${caKey:-${caName}.key}" \
        -CAserial "${caName}.ser" \
        -extfile "${serverName}${restrictionName}_crt.cfg" \
        -extensions x509v3 \
        -extensions extend_cert \
        -sha1 \
        -days ${CertDays} \
        -in "${serverName}${restrictionName}.csr" \
        -out "${serverName}${restrictionName}.crt" \
        -text \
        -certopt no_pubkey,no_sigdump

    if [ $? -ne 0 ]; then
        echo "${myName}:Error: Failed to generate X.509 certificate" 1>&2
        exit 1
    fi

}


generatePKCS12PackageNoCACert () 
{

    # Generate the pkcs12 Keystore only. Dont verify it.
    # Note that you might not have a crt for the CA - for example a web cert may be
    # signed by a third party.

    echo "______________________________________________________________________"
    echo ""
    echo "        Generating PKCS#12 package"
    caName="`${openssl} x509 -noout -text -in ${serverName}${restrictionName}.crt |\
         grep Issuer: | sed -e 's;.*CN=;;' -e 's;/Em.*;;'`"
    echo '' \
    | ${openssl} pkcs12 \
        -export -out "${serverName}${restrictionName}.p12" -passout stdin \
        -password "pass:$Password" \
        -in "${serverName}${restrictionName}.crt" \
        -inkey "${serverName}${restrictionName}.key"  -name "${serverName}" \
        -caname "${caName}"

}




generatePKCS12Package() 
{

    # Generate the pkcs12 format for the cert.
    echo "______________________________________________________________________"
    echo ""
    echo "        Generating PKCS#12 package"


    echo '' \
    | ${openssl} pkcs12 \
          -export -out "${serverName}${restrictionName}.p12" -passout stdin \
          -password "pass:$Password" \
          -in "${serverName}${restrictionName}.crt" \
          -inkey "${serverName}${restrictionName}.key"  -name "${serverName}" \
          -certfile "${caName}.crt" -caname "${caName}"


}

generateJavaKeyStore()
{
    echo "______________________________________________________________________"
    echo ""
    echo "        Generating Java Key Store                                       "


    echo -e "$Password\n$Password" | 
    $JavaCmd \
      -classpath $SipXCommonsDir/sipxcommons.jar \
      org.sipfoundry.commons.PKCS12Import.PKCS12Import \
      "${serverName}${restrictionName}.p12" \
      "${serverName}${restrictionName}.keystore"

}

generateJavaTrustStore()
{

    echo "______________________________________________________________________"
    echo ""
    echo "        Generating Java Trust Store                                   "

    if test -e $TrustStore
    then
       keyExists=`$KeyTool -list  \
                        -keystore "$TrustStore"  \
                        -storepass "$Password" | grep ${aliasName} `

       if [ "${keyExists}" != "" ] 
       then 
          $KeyTool -delete -noprompt -alias "${aliasName}" \
                        -keystore "$TrustStore"  \
                        -storepass "$Password" || exit 1
       fi
    fi
    if [ "${aliasName}" == "${caName}" ] 
    then 
       # add the certificate as the trusted CA certificate.
       ${openssl} x509 -in    "${aliasName}.crt" -outform DER  -out "${aliasName}.der"
       $KeyTool -import -noprompt -alias "${aliasName}" \
                        -keystore "$TrustStore"  \
                        -file "${aliasName}.der" \
                        -noprompt \
                        -trustcacerts \
                        -storepass "$Password" || exit 1
    else 
       ${openssl} x509 -in    "${serverName}${restrictionName}.crt" -outform DER  -out  "${serverName}${restrictionName}.der"
       $KeyTool -import -noprompt -alias "${aliasName}" \
                        -keystore "$TrustStore"  \
                        -noprompt \
                        -file  "${serverName}${restrictionName}.der" \
                        -storepass "$Password" || exit 1
    fi

}



################################################################
#### ACTION FUNCTIONS
#### These combine prompting the user with actually doing things.
################################################################

################################################################
#### Generate only the pkcs and java Keystores. No TrustStores.
#### This method is invoked when installing a web key.
################################################################
doPkcsKeystore()
{
    cat <<EOF

  We need some information from you to generate the certificates:

EOF

    getSubjects
    generatePKCS12PackageNoCACert
    generateJavaKeyStore

    cat <<EOF

    To install your certificate, run the following command
    as root on the server:

    @bindir@/ssl-cert/install-cert.sh
EOF

}


################################################################
####  Install the cert for a new host
####  This method does not generate a CA certificate.
####  This method is called with the severName as argument.
####  It adds a cert to the java keystore that is shipped to 
####  the second host.
################################################################
doAddNewHostCert()
{
    cat <<EOF

  We need some information from you to generate the certificates:

EOF

    getLocality
    getCAInfo
    getSubjects

    seedRand

    aliasName="${serverName}"
    genServerCSR
    signServerCertificate
    generatePKCS12Package
    generateJavaKeyStore
    generateJavaTrustStore

    cat <<EOF

  To install your certificate, run the following command
  as root on the server:

    /usr/local/sipx/bin/ssl-cert/install-cert.sh

EOF
}

################################################################
#### Do the one-step self-signed CA and a certificate from it.
################################################################
doAll()
{
    cat <<EOF

  We need some information from you to generate the certificates:

EOF
    aliasName="${caName}"
    getLocality
    getCAInfo
    getSubjects

    seedRand

    genCA
    genServerCSR
    signServerCertificate
    generatePKCS12Package
    generateJavaKeyStore
    generateJavaTrustStore

    cat <<EOF

  To install your certificate, run the following command
  as root on the server:

    @bindir@/ssl-cert/install-cert.sh

EOF
}

################################################################
#### Create a CA
################################################################
doNewCA()
{
    cat <<EOF

  We need some information from you to set up your Certificate Authority:

EOF

    getLocality
    getCAInfo

    seedRand
    genCA

    cert_expires=`${openssl} x509 -in "${caName}.crt" -noout -enddate | sed 's/notAfter=//'`

    cat <<EOF

  These files have been created for your private Certificate Authority:

       The root certificate of your CA:   "${caName}.crt"

       You will need to make the "${caName}.crt" file available to
       anyone who wishes to be able to validate certificates signed
       by your CA.

             The secret key of your CA:   "${caName}.key"

       You MUST keep the "${caName}.key" file as secure as possible;
       it is the foundation of the security of your CA, and by extension
       anything using certificates signed by your CA.  You may move this
       do removable media; if you do, then when signing keys you must
       specify the full path to the key using the --ca-key switch.

   The serial number store for your CA:   "${caName}.ser"

       This is used to ensure uniqueness when you regenerate certificates.

  The CA certificate will expire ${cert_expires};
  you will need to rerun this command to generate a new certificate
  then (or, preferably, before then).

EOF
}

################################################################
#### CSR
################################################################
doCSR()
{
    cat <<EOF

  We need some information from you to generate the certificate signing request:

EOF

    getLocality
    getSubjects

    seedRand
    genServerCSR

    cat <<EOF
______________________________________________________________________
Results:

   server key:         ${serverName}${restrictionName}.key
   server CSR:         ${serverName}${restrictionName}.csr

  To obtain your certificate from a Certificate Authority, send the
     ${serverName}${restrictionName}.csr
  file to your CA for signing.  When you get the response,
  put the certificate data they give you into:
     ${serverName}${restrictionName}.crt
  and then run this command as root in this directory:

      @bindir@/ssl-cert/install-cert.sh ${serverName}${restrictionName}

  You may also need to install the root certificate from the CA; if this
  is needed, the install-cert.sh command will detect this and provide
  instructions.

EOF

}

showCSR()
{
    ${openssl} req \
        -in "${csrFile}" \
        -text \
        -nameopt RFC2253,multiline \
        -reqopt  no_pubkey,no_sigdump \
        -noout
}

## Extract information from a CSR and present it for approval
checkCSR()
{
    serverName=`${openssl} req -in "${csrFile}" -subject -nameopt RFC2253,multiline -noout \
        | perl -ne 'use English; m/^\s+commonName\s+=\s+/ && print $POSTMATCH'`

    if [ -z "${serverName}" ]
    then
        echo "${myName}:Error: unable to read server name from certificate signing request." 1>&2
        exit 1
    fi

    Subjects=`${openssl} req -in "${csrFile}" -text -noout \
        | grep --after-context=1 'X509v3 Subject Alternative Name:' \
        | tail -n 1`

    if [ -z "${Subjects}" ]
    then
        echo "${myName}:Error: unable to read subjects from certificate signing request." 1>&2
        exit 1
    fi

    getRestrictions

    cat <<EOF

 The data for the requested certificate is:

EOF
    showCSR

    cat <<EOF

 Examine the information above carefully.

 Do you wish to sign a certificate with the above
       for server ${serverName}
   with authority ${caName}

EOF

    answer=""
    until [ "${answer}" = "yes" -o "${answer}" = "no" ]; do
        echo -n "   Sign Certificate? (yes|no): "
        read answer
    done

    test "${answer}" = "no" && exit
}

################################################################
#### Use a CSR to create a Certificate
################################################################
doSignServer()
{
    if [ -z "${csrFile}" ]
    then
        echo "Please specify a CSR file name" 1>&2
        showUsage
        exit 1
    fi

    checkCSR
    signServerCertificate

    cert_expires=`${openssl} x509 -in "${serverName}${restrictionName}.crt" -noout -enddate \
        | sed 's/notAfter=//'`

    cat <<EOF
______________________________________________________________________


   CA certificate:     "${caName}.crt"
   server certificate: ${serverName}${restrictionName}.crt

  To install these certificates and the server key on this system, run the
  following command as root in this directory:

      @bindir@/ssl-cert/install-cert.sh ${serverName}${restrictionName}

  The server certificate will expire ${cert_expires};
  you will need to rerun this command to generate new certificates
  then (or, preferably, before then).  You do not need to create a
  new .csr file - you can just re-sign the same file.

EOF
}


################################################################
#### Generate the Java Truststore using a CA certificate.
################################################################
doCaToTruststore()
{
    cat <<EOF

  We need some information from you to setup the Java Truststore:

EOF

    aliasName=${caName}
    getSubjects
    generatePKCS12Package
    generateJavaTrustStore

    cat <<EOF

    To install your certificate, run the following command
    as root on the server:

    @bindir@/ssl-cert/install-cert.sh
EOF

}



################################################################
#### Generate the Java Keystore using a Host certificate.
################################################################
doCertToKeystore()
{
    cat <<EOF

  We need some information from you to setup the Java Keystore:

EOF

    getSubjects
    generatePKCS12PackageNoCACert
    generateJavaKeyStore

    cat <<EOF

    To install your certificate, run the following command
    as root on the server:

    @bindir@/ssl-cert/install-cert.sh
EOF

}

showCert()
{
    ${openssl} x509 \
        -in "${certFile}" \
        -text \
        -nameopt RFC2253,multiline \
        -certopt no_pubkey,no_sigdump \
        -noout
}


## parse arguments
while [ $# -ne 0 ]
do
    case ${1} in
       --newhost)
          # 
          #Add new host. Insert the public key of the new host into
          #Cached keystore.
          #
          Action=DO_ADD_NEW_HOST
          ;;

        --pkcs)
            ##
            ## Create a key and a Certificate Signing Request
            ##
            Action=DO_PKCS
            ;;

        --csr)
            ##
            ## Create a key and a Certificate Signing Request
            ##
            Action=DO_CSR
            ;;

        --show-csr)
            ##
            ## Display the contents of a Certificate Signing Request
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <csr-file> with ${1}" 1>&2
                Action=USAGE
                break
            else
                csrFile=${2}
                Action=SHOW_CSR
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        --show-cert)
            ##
            ## Display the contents of a Certificate
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <cert-file> with ${1}" 1>&2
                Action=USAGE
                break
            else
                certFile=${2}
                Action=SHOW_CERT
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        --new-ca)
            ##
            ## Create a key and a Certificate Signing Request
            ##
            Action=DO_CA
            ;;

        --ca)
            ##
            ## Certificate Authority Name
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <ca-name> with ${1}" 1>&2
                Action=USAGE
                break
            else
                caName=${2}
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        --ca-key)
            ##
            ## Certificate Authority Key File
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <ca-key-file> with ${1}" 1>&2
                Action=USAGE
                break
            else
                caKey=${2}
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        --sign)
            ##
            ## Sign a CSR to produce a Server Certificate
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <csr-file> with ${1}" 1>&2
                Action=USAGE
                break
            else
                csrFile=${2}
                Action=DO_SERVER
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        --convert-ca2trust)
            ## 
            ## Convert an existing CA certificate to a Java TrustStore
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <ca-cert-file> with ${1}" 1>&2
                Action=USAGE
                break
            else
                caName=${2}
                Action=DO_CA2TRUST
                AutoDefault=AUTODEFAULT
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;
        --convert-crt2jks)
            ## 
            ## Convert an existing host certificate to a Java KeyStore
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <host> with ${1}" 1>&2
                Action=USAGE
                break
            else
                ServerName=${2}
                Action=DO_CRT2JKS
                AutoDefault=AUTODEFAULT
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;
        -e|--email)
            ##
            ## Specify a default contact email address
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <email-address> with ${1}" 1>&2
                Action=USAGE
                break
            else
                defaultEmail=${2}
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        -o|--org)
            ##
            ## Specify the organization name
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <organization-name> with ${1}" 1>&2
                Action=USAGE
                break
            else
                OrganizationName=${2}
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        -d|--defaults)
            AutoDefault=AUTODEFAULT
            ;;

        --web-only)
            RestrictionType=WEB_ONLY
            ;;

        --sip-only)
            RestrictionType=SIP_ONLY
            ;;

        -p|--parameters)
            ##
            ## Set the file from which default answers should be read
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <parameter-file> with ${1}" 1>&2
                Action=USAGE
                break
            else
                Defaults=${2}
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        -s|--server)
            ##
            ## Set the file from which default answers should be read
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <server-name> with ${1}" 1>&2
                Action=USAGE
                break
            else
                ServerName=${2}
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        -D|--domain)
            ##
            ## Set the name of the sip domain uri
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <domain-name> with ${1}" 1>&2
                Action=USAGE
                break
            else
                SipDomainName=${2}
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        -wd|--workdir)
            ##
            ## Set the directory where database files and outputs should be
            ##
            if [ $# -lt 2 ]
            then
                echo "Must specify <working-directory> with ${1}" 1>&2
                Action=USAGE
                break
            else
                WorkDir=${2}
                shift # consume the switch ( for n values, consume n-1 )
            fi
            ;;

        -r|--restricted)
            ##
            ## Limit the domain/server certificate to the specified usage;
            ## For SIP, the extendedKeyUsage restriction oid is:
            ##   iso(1) identified-organization(3) dod(6) internet(1)
            ##   security(5) mechanisms(5) pkix(7) id-kp(3) id-kp-sipDomain(20)
            RestrictedCert=RESTRICTED
            ;;

        -h|--help)
            Action=USAGE
            ;;

        *)
            ##
            ## unrecognized argument
            ##
            echo "Unrecognized option '$1'; try --help" 1>&2
            exit 1
            break
            ;;
    esac

    shift # always consume 1
done

if test -z "${Defaults}"
then
    Defaults=${DefaultDefaults}
fi

if test "${CurrentWorkDir}" != "${WorkDir}"
then
    cd "${WorkDir}" > /dev/null || exit 1
fi

randomFile=${WorkDir}/rnd_seed

test -r ${Defaults} && . ${Defaults}

case ${Action} in

    DO_ALL)
        doAll
        ;;

    DO_ADD_NEW_HOST)
        doAddNewHostCert
        ;;

    DO_PKCS)
        doPkcsKeystore
        ;;

    DO_CA)
        doNewCA
        ;;

    DO_CSR)
        doCSR
        ;;

    SHOW_CSR)
        showCSR
        ;;

    SHOW_CERT)
        showCert
        ;;

    DO_SERVER)
        doSignServer
        ;;

    DO_CA2TRUST)
        doCaToTruststore
        ;;

    DO_CRT2JKS)
        doCertToKeystore
        ;;

    *)
        showUsage
        exit 1
        ;;
esac

exit

# -*- mode: shell-script -*-
