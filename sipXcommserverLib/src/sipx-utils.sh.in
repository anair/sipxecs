#!/bin/sh
###
### Utility script functions common to server startup scripts
###

sipx_services() {
    # Determine whether xargs uses -I or --replace.
    echo | 2>/dev/null xargs -I % echo 
    if test $? -eq 0  ; then
        ls -1 @SIPX_PROCDIR@/*.process.xml | xargs -I % basename % .process.xml
    else
        ls -1 @SIPX_PROCDIR@/*.process.xml | xargs --replace=% basename % .process.xml
    fi
}

sipx_config_value() { # ( CONFIG-FILE, DIRECTIVE )
#   prints the value of DIRECTIVE from CONFIG-FILE
#   list values have any commas removed
    perl -n \
        -e 'use English;' \
        -e 's/#.*$//;' \
        -e "/^\\s*$2\\s*:\\s*/ && print join( ' ', split( /[\\s,]+/, \$POSTMATCH ));" \
        $1
}

dns_sipsrv () { # ( TRANSPORT, DOMAIN )
  # returns the SRV host name for DOMAIN over TRANSPORT
  target=`echo _sip._$1.$2 | tr A-Z a-z`
  dig  -t srv +noidentify +nocmd +nocomments +noquestion +nostats +noauthority ${target} \
  | tr A-Z a-z \
  | awk "\$1 == \"${target}.\" { print \$NF }" \
  | sed 's/\.$//'
  }

dns_cname () { # ( DOMAIN )
  # returns the CNAME resolution for DOMAIN
  target=`echo $1 | tr A-Z a-z`
  dig  -t cname +noidentify +nocmd +nocomments +noquestion +nostats +noauthority ${target} \
  | tr A-Z a-z \
  | awk "\$1 == \"${target}.\" { print \$NF }" \
  | sed 's/\.$//'
  }

dns_a () { # ( DOMAIN )
  # returns the A record resolution for DOMAIN
  target=`echo $1 | tr A-Z a-z`
  dig  -t a +noidentify +nocmd +nocomments +noquestion +nostats +noauthority ${target} \
  | tr A-Z a-z \
  | awk "\$1 == \"${target}.\" { print \$NF }" \
  | sed 's/\.$//'
  }


sip_resolves_to () { # ( unresolved, target )
    # returns true (0) if "unresolved" resolves to "target" (an IP address) by SIP rules
     unresolvedName=`echo $1 | tr A-Z a-z`
     targetAddr=`echo $2 | tr A-Z a-z`

     # If unresolvedName is the target IP address.
     if [ "${unresolvedName}" = "${targetAddr}" ]
     then
         return 0
     fi

     # Look up A records.
     for ip in `dns_a ${unresolvedName}`
     do
       if [ "${ip}" = "${targetAddr}" ]
       then
           return 0
       fi
     done

     # Look up CNAME followed by A records.
     for cName in `dns_cname ${unresolvedName}`
     do
       for ip in `dns_a ${cName}`
       do
         if [ "${ip}" = "${targetAddr}" ]
         then
             return 0
         fi
       done
     done

     # Look up SRV followed by A records.
     for tcpSrv in `dns_sipsrv tcp ${unresolvedName}`
     do
       if [ "${tcpSrv}" = "${targetAddr}" ]
       then
           return 0
       else
           for ip in `dns_a ${tcpSrv}`
           do
             if [ "${ip}" = "${targetAddr}" ]
             then
                 return 0
             fi
           done
       fi
     done

     for udpSrv in `dns_sipsrv udp ${unresolvedName}`
     do
       if [ "${udpSrv}" = "${targetAddr}" ]
       then
           return 0
       else
           for ip in `dns_a ${udpSrv}`
           do
             if [ "${ip}" = "${targetAddr}" ]
             then
                 return 0
             fi
           done
       fi
     done

     return 1
}

get_user_groups() { # USERNAME
    id $1 -Gn
}

get_file_owneruser() { # FILE
    ls -l $1 |  tr -s ' ' | cut -f3 -d' '
}

get_file_ownergroup() { # FILE
    ls -l $1 |  tr -s ' ' | cut -f4 -d' '
}

is_file_owned_by_username() { # FILE, USERNAME
# Returns true (0) if the specified FILE is user owned by the
# specified USERNAME.  Otherwise, returns false (1).

    if [ `get_file_owneruser $1` = $2 ]
    then
        return 0
    else
        return 1
    fi
}

is_file_grouped_by_username() { # FILE, USERNAME
# Returns true (0) if the specified FILE is group owned by one
# (or more) of the groups that the specified USERNAME belongs
# to.  Otherwise, returns false (1).

    file_group=`get_file_ownergroup $1`
    for in_group in `get_user_groups $2`;
    do
        if [ $file_group = $in_group ]
        then
            return 0
        fi
    done

    return 1
}

is_file_executable_by_username() { # FILE, USERNAME
# Returns true (0) if the specified FILE is executable by
# the specified USERNAME, false (1) otherwise.

    # User?
    is_file_owned_by_username $1 $2
    if [ $? = 0 ]
    then
        if [ "$(ls -l $1 | cut -c4)" = "x" ]
        then
            # USERNAME user owns FILE, and has execute permissions.
            return 0
        fi
    else
        # Group?
        is_file_grouped_by_username $1 $2
        if [ $? = 0 ]
        then
            if [ "$(ls -l $1 | cut -c7)" = "x" ]
            then
                # USERNAME is in a group that group owns FILE, and has
                # execute permissions.
                return 0
            fi
        else
            # Other?
            if [ "$(ls -l $1 | cut -c10)" = "x" ]
            then
                # USERNAME is one of the others to the FILE, and has
                # execute permissions.
                return 0
            fi
        fi
    fi

    return 1
}

make_root_writable_only() { # ( FILE )
# This function ensures the specified FILE writable by root only.  It first
# ensures that the file's owner and group are both root.  It then ensures
# that neither group nor other have write permissions on the file.  If a
# chown/chmod fails, then the function returns with the exit status of
# the failed command.  (Note that chown and chmod will fail if the caller
# is not root.)
    if [ -f $1 ]
    then
        # The file exists.  Ensure its owner and group are both root.
        is_file_owned_by_username $1 "root"
        if [ $? = 1 ]
        then
            # The owner is not root, so fix it.
            chown root $1
            if [ 0 != $? ]
            then
                return $?
            fi
        fi
        if [ `uname -s` = FreeBSD ] ; then
           RootGroup="wheel"
        else
           RootGroup="root"
        fi
        if [ `get_file_ownergroup $1` != $RootGroup ]
        then
            # The group is not root, so fix it.
            chown :$RootGroup $1
            if [ 0 != $? ]
            then
                return $?
            fi
        fi

        # At this point the file's owner and group are both root.
        # Ensure it is not writeable by either group or other.
        if [ "$(ls -l $1 | cut -c6)" != "-" ]
        then
            chmod g-w $1
            if [ 0 != $? ]
            then
                return $?
            fi
        fi
        if [ "$(ls -l $1 | cut -c9)" != "-" ]
        then
            chmod o-w $1
            if [ 0 != $? ]
            then
                return $?
            fi
        fi
    fi
}


