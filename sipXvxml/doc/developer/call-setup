Incoming call processing sequence.

How the media server processes a call that is forwarded to it so that
the caller can record a message in the voicemailbox of the callee.

The SIP router sends the call to the media server due to a forwarding
rule in sipXregistry/main/etc/mappingrules.xml.in:

    <url>&lt;sip:{digits}@{mediaserver};voicexml={voicemail}%2Fcgi-bin%2Fvoicemail%2Fmediaserver.cgi%3Faction%3Ddeposit%26mailbox%3D{digits-escaped}&gt;;q=0.1</url>

This line is processed thusly:

During code installation, mappingrules.xml.in is transformed into
mappingrules.xml by replacing ${...} references with installation
parameters.

When the XML is parsed, XML character entities are substituted,
resulting in the mapping result:

    <sip:{digits}@{mediaserver};voicexml={voicemail}%2Fcgi-bin%2Fvoicemail%2Fmediaserver.cgi%3Faction%3Ddeposit%26mailbox%3D{digits-escaped}>;q=0.1

This specifies that the url sip:...{digits} has preference value 0.1
(a low value), so it will be tested after higher preference
destinations have failed.

Once the router decides to use this URL, the {...} references are
replaced with their values.  'digits' is the destination extension
number, 'mediaserver' is the IP address of the media server,
'voicemail' is the base URL of the voicemail URL space on the media
server.  'digits-escaped' is the destination extension number HTTP escaped,
in case odd characters (such as a plus sign) are in the user part.

This SIP URL is dissected to generate a SIP INITIATE request.  The
stuff after "voicexml=" is a SIP URL parameter [see RFC 3261, section
19.1.1], and is used to trigger a voicexml script on the media server,
ala RFC 4240, section 4. 

A later stage of processing will extract the value of the "voicexml="
parameter and reverse the %-encoding of special characters to generate
a URL
"<voicemail>/cgi-bin/voicemail/mediaserver.cgi?action=deposit&mailbox=<digits>".
(Where the items <voicemail> and <digits> were substituted
previously.)  This URL specifies the VXML script that the media server
will process to handle this call.  (The extraction of parameters is
done in the call to getfieldParameter at
IvrCallListener::handleStartVXIsession:284.)

It looks like all the cgi-bin/voicemail/mediaserver.cgi's are
generated by code depending on main() in
sipXpbx/main/src/mediaservercgi/main.cpp.  I don't know what drives
this code, but it appears to be the main() of a separate process that
is somehow incorporated into the sipXpbs software load.  This may be a
separate executable that is invoked by an Apache server (on a
per-request basis?).  The CGI output is created by a DepositCGI object
(created at sipXpbx/main/src/mediaservercgi/main.cpp:408, processed at
980, real work at sipXpbx/main/src/mailboxmgr/DepositCGI.cpp:45).
This VXML script invokes the real processing in
mediaserverUrl/vm_vxml/savemessage.vxml.  In the baseline case, the
CGI produces, which is basically a parameter-setting wrapper for
savemessage.vxml:

    <?xml version="1.0"?>
    <vxml version="2.0">
    <form>

    <var name="msgurl" expr="'greetingUrl'" />
    <var name="msgurltype" expr="'url'"/>

    <subdialog name="send_msg" src="mediaserverUrl/vm_vxml/savemessage.vxml">
    <param name="called_by" value="incoming"/>
    <param name="mailbox" value="m_mailboxIdentity"/>
    <param name="from" value="vxmlFriendlyFrom"/>
    <param name="msgurl" expr="msgurl" />
    <param name="msgurltype" expr="msgurltype" />
    <param name="mediaserverurl" expr="'mediaserverUrl'"/>
    <param name="securemediaserverurl" expr="'secureMediaserverUrl'"/>
    </subdialog>
    </form>
    </vxml>

savemessage.vxml is derived from
../sipXpbx/main/src/wwwcontent/vm_vxml/savemessage.vxml.in and/or
../sipXpbx/main/etc/savemessage.vxml.in

The SIP router sends the call to the media server via a SIP INITIATE
request.

The CallManager task receives the incoming SIP INITIATE request.

At CallManager::CallManager 157, it looks like the call manager is
registering with the "SIP user agent" to receive "SIP_INVITE_METHOD"
messages.  It appears that a/the message queue for the CallManager is
being designated as a place for these messages to be put.  There don't
appear to be any other listeners for these messages.

I am assuming that some low-level library implements the SIP user
agent, and that the user agent transforms the incoming SIP packet into
the internal message format before putting it into the CallManager's
message queue.

At this point (before the media server has accepted the call), only
the CallManager object exists.

This means that CallManager::handleMessage (and only it) is going to
see SIP_INVITE.  It processes it by:

    switch on msgType of the message == PHONE_APP
    switch on msgSubType of the message == CP_SIP_MESSAGE
    findHandlingCall(message) returns NULL
    further test that msgSubType == CP_SIP_MESSAGE
    test that SipMessage::getRequestMethod == SIP_INVITE_METHOD
	(which is "INVITE")

This gets us to CallManager.cpp:483, where the processing starts.

Looks up the user id, which seems to mean the name called.  If it is
not valid, returns "no such user" response.

At 500 test to see if we should create a call, based on
CpPeerCall::shouldCreateCall, which passes off to
SipConnection::shouldCreateConnection.

If so:

At 507 test the size of the "call stack" (via
CallManager::getCallStackSize) to see if it exceeds
MpMediaTask::maxNumManagedFlowgraphs.  If it is at or above that
limit, send a "busy here" response.

At 520 otherwise, create a new SIP call:

new CpPhoneMediaInterface (implementing CpMediaInterface), new
CpPeerCall.

CpPhoneMediaInterface::CpPhoneMediaInterface generates a new
MpCallFlowGraph(locale).  This 'locale' is an argument, which comes
from mLocale.data() in CallManager::handleMessage.
CallManager::mLocale is a class variable, set from the locale argument
to the constructor.  The constructor is called with the default value
for locale, "".  So 'locale' is not how the VXML document gets
designated.

MpCallFlowGraph::MpCallFlowGraph generates a lot of Mp* objects and
attaches them to it.  It also requests the media task to manage the
flow graph (pMediaTask->manageFlowGraph(*this);
pMediaTask->startFlowGraph(*this);). 

As far as I can tell, the flow graph and the *MediaInterface objects
are entirely to handle the streaming of the audio.  These are
ultimately processed by the media server thread.

The CpPeerCall object represents the call (session).

CpPeerCall::CpPeerCall sub-invokes the constructor CpCall::CpCall.

CallManager continues with CpPeerCall::start (via
handlingCall->start), starting a new thread.

CallManager calls CallManager::addTaoListenerToCall on the CpPeerCall
object (576), which applies CpCall::addTaoListener to all the
listeners that have been added to the CallManager object.  That is,
the listeners attached to the CallManager seem to be archived so that
they can be duplicated onto the CpCall's that are created.  It does
not appear that the listeners on CallManager can be activated
directly, since CallManager::postTaoListenerMessage is never called.
CpCall::addTaoListener calls CpCall::addListener, which adds them to
its list of listeners.

Add it to the call stack with pushCall.

Post the incoming message to the event queue of the CpPeerCall object.

Now, processing continues in the CpPeerCall thread.

The CpPeerCall object processes the message using
CpCall::handleMessage.  It switches on msgType == PHONE_APP, which
switches on msgSubType to the default, which calls
CpPeerCall::handleCallMessage.

CpPeerCall::handleCallMessage switches on msgSubType and calls
CpPeerCall::handleSipMessage.  That's starting to descend into the SIP
call state processing.

****

We're probably getting to the point where the work is handed over to
the Tao object.  But I've yet to decrypt how that connection is made.
It's probably made through the event listening / upcall mechanism.

It's done by invocation of postTaoListenerMessage inside CallManager.
(CpCall handles its TaoListeners the same way.)  But nobody calls that
function for CallManager, apparently.

****

Hmm, none of the calls of CpPeerCall::postTaoListenerMessage seem to
come from routines that would get activated in a normal call
establishment.

****

Now, processing continues in the IvrCallListener thread.

The incoming call message is probably obtained from the CallManager
via the IvrCallListener attached to it as a listener. (IvrCallListener
is a subclass of TaoAdaptor.)  Looking at
IvrCallListener::handleMessage, there seem to be two messages,
CONNECTION_OFFERED, and TERMINAL_CONNECTION_TALKING.  The former calls
IvrCallListener::handleAcceptCall.  The latter calls
IvrCallListener::handleStartVXISession.

IvrCallListener::handleStartVXISession

Extract the voicexml parameter from the SIP requestUrl.  Append
"&from=<caller address>".  Probably leavs an appended parameter which
is the original extension number that was called.  Call VXIProcessUrl.

VXIProcessUrl

Assemble URL of VXML document from 'url' argument.  If url contains
http, then use it.  Otherwise, prepend gblDefaultVxmlURL.

Create a VXIMap, presumably to hold the state of the VXML session, via
VXIMapCreate.  Create ChannelThreadArgs object.  Create VXIplatform
object.  Initialize fields of ChannelThreadArgs object, including
VXIMapClone of VXIMap we created above.  Create thread executing
ChannelThread with arguments in ChannelThreadArg object.

Now, processing continues in ChannelThread thread.

ChannelThread (sipXvxml/src/client/ivr/clientMain.cpp:1146)

Sets up a lot of stuff for VXI.  Then calls VXIplatformProcessDocument
to do the real work.

VXIplatformProcessDocument is at sipXvxml/src/client/api/OSBclient.cpp:813.
Initializes cookie-handling code!
Sets up prompt interface:

  promptResult = platform->VXIprompt->BeginSession(platform->VXIprompt, sessionArgs);

and other subordinates to VXI.  Loads up lots of pointers into a
'platform' object and runs VXI via:

  interpreterResult = platform->VXIinterpreter->Run(platform->VXIinterpreter,
