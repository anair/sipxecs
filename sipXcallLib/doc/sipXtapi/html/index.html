<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SipX TAPI-like API for Call Processing: sipXtapi SDK Overview</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindexHL" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>sipXtapi SDK Overview </h1>
<p>
<p align="center">by Bob Andreasen</p>
<p>The sipXtapi SDK is a C application programming interface for voice communications
 over IP. Specifically, sipXtapi provides a generalized telephony interface on
 top of the Session Initiation Protocol (SIP), RFC 3261, and the real-time Transport
 Protocol (RTP), RFC 1889. While the SIP and RTP protocols provide signaling and
 media transport infrastructure, sipXtapi also includes many other protocol and
 standards implementations needed for voice communications.</p>
<p>sipXtapi is developed under open source and hosted as part of the sipX line
 of projects available from SIPfoundry. It is licensed under LGPL which allows
 commercial usage of the library without the &#8220;viral infection&#8221; associated
 with GPL. Essentially, you may use the code as-is and build on top of it without
 exception, however, if you modify the existing code (e.g. bug fix), you must
 make changes available under LGPL. For more information on open source licensing
 or SIPfoundry, please see www.opensource.org or www.sipfoundry.org.</p>
<p>The technology used underneath sipXtapi was donated by Pingtel Corp (www.pingtel.com)
 in March of 2004 when they took their IP PBX and soft phone solutions open source.
 The technology base was and still is used for their proxy servers, media server,
 soft phone, and hard phone appliance. The technology is considered well tested
 and very interoperable with other SIP devices.</p>
<h2>Objectives</h2>
<p> The primary objective for sipXtapi is to provide a simple programming interface
 for application developers. As standards-based protocols; such as SIP, become
 more popular, enterprises and independent software vendors will provide value-added
 solutions on top a of a now-commodity voice infrastructure. sipXtapi is designed
 to enable this class of developers by providing a simple solution that abstracts
 many of the intricate details of SIP. Developers using sipXtapi do not need to
 understand the syntax and semantics of the underlying protocols and can focus
 on a more familiar call model. </p>
<p>Another objective included building an API that was familiar to application
 developers in telephony. A number of call models exist today, however, Microsoft
 TAPI 2.2 was chosen as a conceptual base because of its popularity and good separation
 of line or end point specific features and call center features. Porting a TAPI
 2.2 application to sipXtapi requires changes, however, is consider straight forward.</p>
<p>While building full TAPI service provider model under Windows is an eventual
 goal, cross platform usage is also a key objective. The sipXtapi SDK builds and
 runs under Windows, Linux; and MacOS support is planned. The underlying technologies
 have also been executed on Solaris, embedded Linux, and vxWorks.</p>
<h2>Feature Set</h2>
<div align="center">
 <table width="90%" border="0">
  <tr>
   <td><ul>
     <li>TAPI-like API</li>
     <li>Multiple simultaneous calls</li>
     <li>Hold/Unhold, Mute/Unmute</li>
     <li>Volume and Gain control</li>
     <li>Selectable audio input device, speaker device, and ringer device</li>
     <li>Logical separation between ringer and speaker</li>
     <li>Silent Call Forwarding and Rejection</li>
     <li>Tone Generation (DTMF, busy, ring back, etc.)</li>
     <li>Play audio from file</li>
     <li>Bind to specific network interfaces<br>
     </li>
    </ul></td>
   <td><ul>
     <li>RFC3261 compliant SIP stack</li>
     <li>RFC2833 Out of band DTMF tones</li>
     <li>RTP suppression on mute</li>
     <li>Configurable Ports (UDP, TCP, and RTP)</li>
     <li>Multiple SIP identities (line appearances)</li>
     <li>Line authentication</li>
     <li>DNS SRV timeout control</li>
     <li>SIP Proxy control</li>
     <li>Rport</li>
     <li>G711 Codec</li>
     <li>Fixed non-adaptive jitter buffer</li>
    </ul></td>
  </tr>
 </table></div>
<h2>Possible Uses</h2>
<p>Using sipXtapi as the base for soft phone client is the most obvious and straight
 forward use. This API was developed to facilitate SIPfoundry&#8217;s next generation
 soft phone and is heavily tested for that purpose. Basic telephony features are
 supported along with more advanced features such as client-side conference and
 transfer.</p>
<p>Developers are also using sipXtapi to add soft phone-like features to their
 existing products. This is a slightly different application than a traditional
 soft phone; however, the basics are identical.</p>
<p>sipXtapi is also targeted to server-based user agents. The API can be configured
 to avoid the use of local audio inputs and outputs. For example, the sipXtapi
 SDK is positioned to become to call processing engine being SIPfoundry&#8217;s
 sipXvxml project. The sipXvxml project is a VoiceXML driven engine that provides
 SIP IVR functionality.</p>
<p>sipXtapi provides a quick method to add SIP to a legacy telephony product.
 The API provides hooks for sourcing and consuming audio data. When combined in
 a back-to-back user agent (B2BUA) configuration, developers have successful bridged
 legacy to SIP communication.<br>
</p>
<h2> sipXtapi Basics</h2>
<h3> SIPX_ handles</h3>
<p> Virtually all of the sipXtapi API methods require one or more handles as function
 arguments. SIPX_ handles represent all of the data associated with a logic call,
 conference, line identity, or user agent instance. A brief description of each
 handle type is provided in Table 1 (below).</p>
<p align="center">Table 1: sipXtapi Handles </p>

<div align="center">
 <table width="80%" border="1">
  <tr>
   <th>Handle</th>
   <th>Description</th>
  </tr>
  <tr>
   <td>SIPX_INST</td>
   <td>The SIPX_INST handle represents an instance of a user agent. A user agent
    includes a SIP stack and media processing framework. sipXtapi does support
    multiple instances of user agents in the same process space, however, certain
    media processing features become limited or ambiguous. For example, only one
    user agent should control the local system's input and output audio devices.</td>
  </tr>
  <tr>
   <td>SIPX_LINE</td>
   <td>The SIPX_LINE handle represents an inbound or outbound identity. When placing
    outbound calls, the application programmer must define the outbound line.
    When receiving inbound calls, the application can query the line.</td>
  </tr>
  <tr>
   <td>SIPX_CALL</td>
   <td>The SIPX_CALL handle represents a call or connection between the user agent
    and another party. All call operations require the call handle as a parameter.</td>
  </tr>
  <tr>
   <td>SIPX_CONF</td>
   <td>The SIPX_CONF handle represents a collection of SIPX_CALLs that have bridge
    (mixed) audio. Application developers can manipulate each leg of the conference
    through various conference functions.</td>
  </tr>
 </table>
</div>
<p align="left">Handle life cycles are managed both by the framework and the application
 developer. Handles such as SIPX_INST and SIPX_LINE are explicitly created and
 destroyed by application developers. SIPX_CONF and SIPX_CALL handles are explicitly
 created by the application developer, however, are destroyed automatically at
 the end of the session. When receiving a new inbound call, a SIPX_CALL handle
 is implicitly created by the framework.</p>
<h3 align="left">Functional Method Groups</h3>
<p>All of the API functions in sipXtapi can be categorized in functional groups.
 The grouping is derivable from the method names. For example &#8220;sipXcallAccept(&#8230;)&#8221;,
 &#8220;sipXcallReject(&#8230;)&#8221;, and &#8220;sipXcallRedirect(&#8230;)&#8221;
 are all call related functions, while &#8220;sipxConferenceGetCalls(&#8230;)&#8221;
 is a conference function. A brief summary of each functional area is provided
 in Table 2 (below).<br>
</p>
<p align="center"> Table 2: Functional Method Groups</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <th>Functional Area</th>
   <th>Description</th>
  </tr>
  <tr>
   <td>Config</td>
   <td><p>sipXtapi includes a number of configuration settings that allow application
     developers to set the SIP proxy server, timeout settings, enabling/disable
     specific SIP such as symmetric signaling.</p>
    <p>Settings can be change at any point; however, all settings may not affect
     calls already in progress.</p></td>
  </tr>
  <tr>
   <td>Call</td>
   <td><p>Call features include accepting, rejecting, and redirecting new inbound
     calls; answering, holding, mute, playing tones, playing audio files, and
     transferring active calls; and accessing called and caller ID.</p></td>
  </tr>
  <tr>
   <td>Line</td>
   <td><p>sipXtapi provides methods to define lines (SIP identities). Lines are
     modeled after the LEDs found on key-system telephone handsets. Generally,
     lines represent both outside PSTN lines and inbound queues such as the sale
     and support queue. In sipXtapi, lines are defined in terms of SIP identities.
     Each identity is optionally configured to register with a SIP registrar.
     Authentication credentials are configured on a per line basis.</p>
    <p>This mechanism allows for both peer-to-peer environments where users setup
     calls using IP addresses or host names and central directory-oriented environments
     with authenticated clients registered with a well known registrar.</p></td>
  </tr>
  <tr>
   <td>Audio</td>
   <td><p>sipXtapi provides methods to enumerate audio devices, select the in-call
     speaker device, select the ringer device, and set the input device. Additionally,
     APIs are available for setting speaker volume and microphone gain levels.
     For servers, application developers may disable microphone and speakers.</p></td>
  </tr>
  <tr>
   <td>Conference</td>
   <td><p>Adhoc client-mixed conferences are setup and manipulate through a series
     of conferencing APIs. Application developers may add and remove conference
     participants and place individual conference participants on hold.</p></td>
  </tr>
  <tr>
   <td>Events</td>
   <td><p>A callback mechanism (observer pattern) is used to communicate call
     state transitions to the application layer. A small number of major events
     allow for simple application state machines and streamlined processing. Minor
     events provide additional information and causes for major event transitions.</p></td>
  </tr>
  <tr>
   <td>Hooks</td>
   <td><p>Application developers can &#8220;hook&#8221; audio sources and targets
     to consume or manipulate audio. This mechanism enables audio logging, audio
     injection, and audio capture. Additionally, this mechanism has been used
     to bridge non-SIP voice clients to SIP voice clients using a back to back
     user agent (B2BUA) approach.</p></td>
  </tr>
 </table>
</div>
<h3>Events</h3>
<p>The sipxTapi API uses events to communicate state transitions to the application
 layer. Since many of the API calls are asynchronous, events notifications must
 be reviewed for both operations such as placing a call and externally generated
 events such as the remote party disconnecting. Descriptions of the major events
 are listed in Table 3.</p>
<p></p>
<p align="center">Table 3: Major events</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <th><p>Major Event</p></th>
   <th><p>Description</p></th>
  </tr>
  <tr>
   <td><p>NEWCALL</p></td>
   <td><p>The NEWCALL event indicates that a new call has been created automatically
     by the sipXtapi. This event is most frequently generated in response to an
     inbound call request.</p></td>
  </tr>
  <tr>
   <td><p>DIALTONE</p></td>
   <td><p>The DIALTONE event indicates that a new call has been created for the
     purpose of placing an outbound call. The application layer should determine
     if it needs to simulate dial tone for the end user.</p></td>
  </tr>
  <tr>
   <td><p>REMOTE_OFFERING</p></td>
   <td><p>The REMOTE_OFFERING event indicates that a call setup invitation has
     been sent to the remote party. The invitation may or may not every receive
     a response. If a response is not received in a timely manor, sipXtapi will
     move the call into a disconnected state. If calling another sipXtapi user
     agent, the reciprocate state is OFFER.</p></td>
  </tr>
  <tr>
   <td><p>REMOTE_ALERTING</p></td>
   <td><p>The REMOTE_ALERTING event indicates that a call setup invitation has
     been accepted and the remote user is in the alerting state (ringing). Depending
     on the SIP configuration, end points, and proxy servers involved, this event
     should only last for up to 3 minutes. Afterwards, the state will automatically
     move to DISCONNECTED. If calling another sipXtapi user agent, the reciprocate
     state is ALERTING</p></td>
  </tr>
  <tr>
   <td><p>CONNECTED</p></td>
   <td><p>The CONNECTED state indicates that call has been setup between the local
     and remote party. Audio should be flowing provided and the microphone and
     speakers should be engaged.</p></td>
  </tr>
  <tr>
   <td><p>DISCONNECTED</p></td>
   <td><p>The DISCONNECTED state indicates that a call was disconnected or failed
     to connect. A call may move into the DISCONNECTED states from almost every
     other state. For more information on the causes for a DISCONNECTED event,
     please review the DISCONNECTED minor states codes.</p></td>
  </tr>
  <tr>
   <td><p>OFFERING</p></td>
   <td><p>An OFFERING state indicates that a new call invitation has been extended
     this user agent. Application developers should invoke sipxCallAccept(), sipxCallReject()
     or sipxCallRedirect() in response. Not responding will result in an implicit
     call sipxCallReject().</p></td>
  </tr>
  <tr>
   <td><p>ALERTING</p></td>
   <td><p>An ALERTING state indicates that an inbound call has been accepted and
     the application layer should alert the end user. The alerting state is limited
     to 3 minutes in most configurations; afterwards the call will be canceled.
     Applications will generally play some sort of ringing tone in response to
     this event.</p></td>
  </tr>
  <tr>
   <td><p>DESTROYED</p></td>
   <td><p>The DESTORYED event indicates the underlying resources have been removed
     for a call. This is the last event that the application will receive for
     any call. The call handle is invalid after this event is received.</p></td>
  </tr>
  <tr>
   <td><p>UNKNOWN</p></td>
   <td><p>An UNKNOWN event is generated when the state for a call is no longer
     known. This is generally an error condition; see the minor event for specific
     causes.</p></td>
  </tr>
 </table>
</div>
<p>In Figure 1, the state diagram depicts the typical life cycle for an outbound
 call. An event is sent to the application developers on state transitions. Details
 on each event can be found in Table 4 and the sipXtapi documentation.</p>
<p align="center">Figure 1: Events for an outbound call</p>
<p align="center"><img src="callevents_outbound.gif" width="550" height="471"></p>
<p align="center">&nbsp;</p>
<p>In Figure 2, the state diagram describes the typical life cycle for an inbound
 call. The &#8220;OFFERING&#8221; event signals a request for a connection and
 the application developer can choose to accept the call, reject the call, or
 redirect the call. Note: Accepting the call is precursor to altering (or ringing)
 the user.</p>
<p align="center">Figure 2: Events for an inbound call</p>
<p align="center"><img src="callevents_inbound.gif" width="555" height="429"></p>
<p>&nbsp;</p>
<h2>Example 1: Placing a simple call</h2>
<p>This example demonstrates how to setup a basic call, monitor states, and then
 clean up the call. The example assumes that the remote party will initiate the
 hang up.</p>
<h3>sipXtapi Setup</h3>
<p align="center">Figure 3: sipXtapi Setup</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>
1: SIPX_INST g_hInst;<br>2: SIPX_LINE g_hLine;<br>3: SIPX_CALL g_hCall;<br>4: <br>5: sipxInitialize(&amp;g_hInst, SIP_PORT, TCP_PORT, RTP_START_PORT);<br>6: sipxListenerAdd(g_hInst, EventCallbackProc, NULL);<br>7: <br>8: sipxLineAdd(g_hInst, &#8220;sip:myidentity@example.com&#8221;, true, &amp;g_hLine);<br>9: sipxLineAddCredential(g_hLine, &#8220;myidentity&#8221;, &#8220;mypassword&#8221;, &#8220;example.com&#8221;);</pre></td>
  </tr>
 </table>
</div>
<p align="left">In Figure 3, lines 1 to 3 define global variables that are used
 throughout the example: user agent instance, default line identity, and call
 handle.<br>
 Line 5 initializes the user agent and specifies the default port settings. SIP_PORT
 and TCP_PORT are traditionally 5060 and define the SIP signaling ports. RTP_START_PORT
 defines the starting port for RTP audio traffic. sipXtapi will allocate two adjacent
 audio ports (RTP &amp; RTCP) for each call.</p>
<p align="left">Line 6, adds a callback procedure for event notifications.</p>
<p>Lines 7 and 9 define a line identity and add authentication credentials for
 that line.</p>
<h3> Placing Call</h3>
<p align="center">Figure 4: Placing outbound call</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>1: sipxCallCreate(g_hInst, g_hLine, &amp;g_hCall);   <br>2: sipxCallConnect(g_hCall, &#8220;My Friend &lt;sip:myfriend@example.com&gt;&#8221;);<br></pre></td>
  </tr>
 </table>
</div>
<p>In Figure 4, a basic call is created and initiated to &#8220;sip:myfriend@example.com&#8221;.
 The line created in Figure 3 was specified and is used for the outbound call
 identity. Results from the connection attempt are delivered asynchronously though
 event call backs. However, sipxCallConnect(&#8230;) may yield a non-successful
 return code if the address is malformed or if the domain name is invalid.</p>
<h3><br>
 Event callback signature</h3>
<p align="center">Figure 5: Call back signature</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>1: void EventCallbackProc( SIPX_CALL hCall,<br>2:                         SIPX_LINE hLine,<br>3:                         SIPX_CALLSTATE_MAJOR eMajor,<br>4:                         SIPX_CALLSTATE_MINOR eMinor,  <br>5:                         void* pUserData)<br>6: {<br>7:     switch (eMajor)<br>8:     {<br>9:         case NEWCALL:<br>10:            break ;<br>11:        case DIALTONE:<br>12:            break ;<br>13:        case REMOTE_OFFERING:<br>14:            break ;<br>15:        case REMOTE_ALERTING:<br>16:            break ;<br>17:        case CONNECTED:<br>18:            break ;<br>19:        case DISCONNECTED:<br>20:            break ;<br>21:        case OFFERING:<br>22:            break ;<br>23:        case ALERTING:<br>24:            break ;<br>25:        case DESTROYED:<br>26:            break ;<br>27:        case UNKNOWN:<br>28:            break ;<br>29:    }<br>30:}</pre></td>
  </tr>
 </table>
</div>
<p>Figure 5 provides a skeleton for an event call back. See Table 3 for description
 of the major event states. Call backs are invoked on a sipXtapi thread context
 and should not be blocked by the application layer. For a description of the
 callback parameters, see Table 4.</p>
<p align="center">Table 4: Call back parameters</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <th><p>Parameter</p></th>
   <th><p>Description</p></th>
  </tr>
  <tr>
   <td><p>SIPX_CALL</p></td>
   <td><p>Handle to the call associated with the state change</p></td>
  </tr>
  <tr>
   <td><p>SIPX_LINE</p></td>
   <td><p>Line associated with the call. This is most useful when receiving new
     calls.</p></td>
  </tr>
  <tr>
   <td><p>SIPX_CALLSTATE_MAJOR</p></td>
   <td><p>The new major event state. See Figures 1 and 2 and the Table 4 for descriptions.</p></td>
  </tr>
  <tr>
   <td><p>SIPX_CALLSTATE_MINOR</p></td>
   <td><p>The minor event state (or cause code). The cause code gives more meaning
     behind the major code. For example, was the call disconnected because the
     remote party was busy or because the remote party hung up? See the sipXtapi
     documentation for descriptions.</p></td>
  </tr>
  <tr>
   <td><p>void*</p></td>
   <td><p>Application data specified when the listener was first added.</p></td>
  </tr>
 </table>
</div>
<h3>Handling remote offered event</h3>
<p align="center">Figure 6: Handling remote offered</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>1: handleRemoteOffered(SIPX_CALL hCall, SIPX_CALLSTATE_MINOR eMinor)<br>2: {<br>3:     char cCallId[512] ;<br>4:     sipxCallGetID(hCall, cCallId, sizeof(cCallId)) ; <br>5:     printf(&#8220;%s: Trying&#8230;&#8221;, cCallId) ;<br>6: }<br></pre></td>
  </tr>
 </table>
</div>
<p>The REMOVE_OFFERING event does not require any action. Generally application
 developers will display status indicating the progress of the call.<br>
</p>
<h3>Handling remote alerting event</h3>
<p align="center">Figure 7: Handling remote alerting</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>1: handleRemoteAlerting(SIPX_CALL hCall, SIPX_CALLSTATE_MINOR eMinor)<br>2: {<br>3:     char cCallId[512] ;<br>4:     sipxCallGetID(hCall, cCallId, sizeof(cCallId)) ; 	<br>5:     printf(&#8220;%s: Alerting&#8230;&#8221;, cCallId) ;<br>6: <br>7:     if (REMOTE_ALERTING_MEDIA != eMinor)<br>8:     {<br>9:         sipxCallStartTone(hCall, ID_TONE_RINGBACK, true, false) ;<br>10:    }<br>11:}</pre></td>
  </tr>
 </table>
</div>
<p align="left">Like REMOTE_OFFERING, the REMOTE_ALERTING event is used to provide
 feedback to the end user. The code snipped in Figure 7 will play a ring back
 tone to the end user if &#8220;early media&#8221;, audio sent along with the
 alerting indication, is not present. Early media is detectable by looking minor
 call state event. Early media is often provided by PSTN gateways to provide audible
 call status.<br>
</p>
<h3>Handling connected event</h3>
<p align="center">Figure 8: Handling connected</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>1: handleConnected(SIPX_CALL hCall, SIPX_CALLSTATE_MINOR eMinor)<br>2: {<br>3:     char cCallId[512] ;<br>4:     sipxCallGetID(hCall, cCallId, sizeof(cCallId)) ; 	<br>5:     printf(&#8220;%s: Connected.&#8221;, cCallId) ;<br>6: <br>7:     sipxCallStopTone(hCall) ;<br>8: }<br></pre></td>
  </tr>
 </table>
</div>
<p>The CONNECTED state is significant for user feedback, however, does not require
 any actions from the application developer. The application layer should pay
 attention to the minor state events for changes in the connected event. For example,
 the call may be placed on or off hold.</p>
<h3>Handling remote disconnected event </h3>
<p align="center">Figure 9: Handling disconnected</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>1: handleDisconnected(SIPX_CALL hCall, SIPX_CALLSTATE_MINOR eMinor)<br>2: {<br>3:     char cCallId[512] ;<br>4:     sipxCallGetID(hCall, cCallId, sizeof(cCallId)) ; 	<br>5:     printf(&#8220;%s: Disconnected.&#8221;, cCallId) ;<br>6: <br>7:     sipxCallDestroy(hCall) ;<br>8: }<br></pre></td>
  </tr>
 </table>
</div>
<p>The DISCONNECTED event is generated in many different scenarios. Examples range
 from locally hang up, the remote party hanging up, a busy end point, a network
 outage, etc. It is important to look at the minor call state code to determine
 the reason for the disconnection and take an appropriate action. In Figure 9,
 the code snippet blindly destroys the call; however, if the minor code was DISCONNECTED_BUSY,
 one might want to play a busy tone as audible feedback. Once the end user acknowledged
 the failure, the application developer would then destroy the call.<br>
</p>
<h2>Example 2: Receiving a call; audio loopback </h2>
<p>This example demonstrates how to receive a call and use media hooks to build
 a simple audio loopback device. The basic sipXtapi setup and event skeleton is
 identical to Example 1. However, additional setup is required along with different
 event processing.</p>
<p>NOTE: This example assumes that only one call is active at any point in time.</p>
<h3>Handling offering event</h3>
<p align="center">Figure 10: Handling offering event</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>1: handleOffering(SIPX_CALL hCall, SIPX_CALLSTATE_MINOR eMinor)<br>2: {<br>3:     char cCallId[512] ;<br>4:     sipxCallGetID(hCall, cCallId, sizeof(cCallId)) ; 	<br>5:     printf(&#8220;%s: Offered.&#8221;, cCallId) ;<br>6: <br>7:     sipxCallAccept(hCall) ;<br>8: }<br></pre></td>
  </tr>
 </table>
</div>
<p>Upon receiving an OFFERING event, the application developer must accept, reject,
 or redirect the call. In this example, the call is accepted; however, one should
 consider rejecting the call if resources are limited or the end users has decided
 to hold all calls, etc. Depending on the SIP environment, the user agent may
 redirect calls to another user agent (e.g. voicemail) when the phone is busy.
 In many architects that decision is pushed into the network and the end point
 is expected to only reject calls.</p>
<h3>Handling alerting event</h3>
<p align="center">Figure 11: Handling alerting event</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>1: handleAlerting(SIPX_CALL hCall, SIPX_CALLSTATE_MINOR eMinor)<br>2: {<br>3:     char cCallId[512] ;<br>4:     sipxCallGetID(hCall, cCallId, sizeof(cCallId)) ; 	<br>5:     printf(&#8220;%s: Alerting.&#8221;, cCallId) ;<br>6: <br>7:     clearLoopback() ;<br>8:     sipxCallAnswer(hCall) ;<br>9: }<br></pre></td>
  </tr>
 </table>
</div>
<p>The ALERTING event signifies that a call has been accepted and the end user
 should be alerted. In a soft phone, one would alert the user by playing a ring
 tone or a custom ring file. This example automatically answers the calls. The
 clearLookback() call is described later.</p>
<h3>Loopback routines</h3>
<p align="center">Figure 12: Loopback routines</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>1: #define SAMPLES_PER_FRAME   80<br>2: #define LOOPBACK_LENGTH     200<br>3: <br>4: static short* g_loopback_samples[LOOPBACK_LENGTH] ;<br>5: static short g_loopback_head = 0 ;<br>6: <br>7: void clearLoopback()<br>8: {<br>9:     for (int i=0; i&lt;LOOPBACK_LENGTH; i++)<br>10:    {<br>11:        if (g_loopback_samples[i])<br>12:        {<br>13:            memset(g_loopback_samples[i], 0, <br>14:                    sizeof(short) * SAMPLES_PER_FRAME) ;<br>15:        }<br>16:    }<br>17:    g_loopback_head = 0 ;<br>18:}<br>19:<br>20:void initLoopback()<br>21:{<br>22:    for (int i=0; i&lt;LOOPBACK_LENGTH; i++)<br>23:    {<br>24:        g_loopback_samples[i] = new short[SAMPLES_PER_FRAME] ;        <br>25:    }<br>26:    clearLoopback() ;<br>37:}</pre></td>
  </tr>
 </table>
</div>
<p>A very simple loopback ring buffer is defined and initialized in Figure 12.
 For this example, the samples per frame and loopback delay are fixed at 80 samples/frame
 (8000Hz) and 200 frames (2 seconds).</p>
<p>initLoopback() and clearLoopback() are helper functions. The initLoopback()
 method allocates enough memory to hold samples during the delay period. The clearLoopback
 routine is called between calls to clears all of the samples. Samples are formatted
 as mono, 16-bit signed, little endian PCM.<br>
</p>
<h3>Hook implementation</h3>
<p align="center">Figure 13: Hook implementation</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>1: void SpkrAudioHook(const int nSamples, const short* pSamples) <br>2: {  <br>3:     memcpy(g_loopback_samples[g_loopback_head], pSamples, <br>4:             sizeof(short) * SAMPLES_PER_FRAME) ;<br>5:     g_loopback_head = ((g_loopback_head + 1) % LOOPBACK_LENGTH) ;<br>6: }<br>7: <br>8: void MicAudioHook(const int nSamples, short* pSamples) <br>9: {   <br>10:    short index = ((g_loopback_head + 1) % LOOPBACK_LENGTH) ;<br>11:    memcpy(pSamples, g_loopback_samples[index], sizeof(short) *<br>12:            SAMPLES_PER_FRAME) ;            <br>13:}</pre></td>
  </tr>
 </table>
</div>
<p>The sipXtapi SDK allows application developers to hook audio sources and targets
 to inject or consume audio. For this example, data heading for the speaker is
 stored in a ringer buffer and later injected as microphone source data. With
 the 200 frame delay, the remote calling party will hear their voice 2 seconds
 later.</p>
<h3>Additional call setup</h3>
<p align="center">Figure 14: Additional call setup</p>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <td><pre>1: initLoopback() ;<br>2: sipxConfigSetSpkrAudioHook(SpkrAudioHook) ;<br>3: sipxConfigSetMicAudioHook(MicAudioHook) ;    <br></pre></td>
  </tr>
 </table>
</div>
<p>Plugging in the loopback code is fairly easy. One needs to initialize the loopback
 data structure and set the speaker and microphone audio hooks as demonstrated
 in Figure 14.</p>
<h2>More Information</h2>
<div align="center">
 <table width="80%" border="1">
  <tr>
   <th><p>Method</p></th>
   <th><p>Description / Instructions</p></th>
  </tr>
  <tr>
   <td><p>Review API Definition</p></td>
   <td><p>API documentation is automatically generated from the source code by
     doxygen. Please click the <a href="files.html">&quot;Files&quot; link</a>
     on the top of this page to access detailed documentation.</p></td>
  </tr>
  <tr>
   <td><p>Latest Docs</p></td>
   <td><p>The latest overview and API documentation is found in SIPfoundry source
     code repository. This information is reviewed easily online:<br>
     <a href="http://scm.sipfoundry.org/rep/sipXcallLib/main/doc/sipXtapi/html/index.html">http://scm.sipfoundry.org/rep/sipXcallLib/main/doc/sipXtapi/html/index.html</a></p></td>
  </tr>
  <tr>
   <td><p>SIPfoundry Web Site</p></td>
   <td><p>The sipXtapi project is a included as part of the sipXcallLib project.
     Please review the sipXcallLib project page for additional information:<br>
     <a href="http://www.sipfoundry.org/sipXcallLib/index.html">http://www.sipfoundry.org/sipXcallLib/index.html</a></p></td>
  </tr>
  <tr>
   <td><p>Example source code</p></td>
   <td><p>Example source code is provide with the sipXcallLib project. You will
     need to fetch the sipXcallLib, sipXtackLib, sipXmediaLib, and sipXportLib
     projects to build sipXtapi, however, source examples are easily reviewed
     online:</p>
    <dl>
     <dt><a href="http://scm.sipfoundry.org/rep/sipXcallLib/main/examples/PlaceCall/">PlaceCall
      Example</a></dt>
     <dd>Command line utility for placing calls</dd>
     <dt><a href="http://scm.sipfoundry.org/rep/sipXcallLib/main/examples/ReceiveCall/">Receive
      Call Example</a></dt>
     <dd>Command line utility for receiving calls</dd>
     <dt><a href="http://scm.sipfoundry.org/rep/sipXcallLib/main/examples/CallScript/">CallScript
      Example</a></dt>
     <dd>Command line utility used place many calls</dd>
     <dt><a href="http://scm.sipfoundry.org/rep/sipXcallLib/main/examples/sipXezPhone/">sipXezPhone
      Example</a></dt>
     <dd>wxWindows based softphone example by Michael Cohen</dd>
    </dl></td>
  </tr>
  <tr>
   <td><p>sipX developer mailing list</p></td>
   <td><p>The <a href="https://list.sipfoundry.org/mailman/listinfo/sipx-dev">sipX-dev
     mailing list</a> is useful for find answers to questions not covered by any
     of the other sources. Please search the archive for answers before posting
     your question.</p></td>
  </tr>
 </table>
</div>
<p>&nbsp;</p>
<p>Problems with these docs? Please email bob AT sipfoundry.org.</p>
 <hr size="1"><address style="align: right;"><small>Generated on Fri May 13 16:20:12 2005 for SipX TAPI-like API for Call Processing by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
