#! /usr/bin/env python

#----------------------------------------------------------------------
#
# Copyright (C) 2006 Pingtel.Corp.
#
# This script performs SIPX installation on post-anaconda
# on a Linux host that was pre-installed using a SIPX installation CD or
# for the Linux Fedora LiveCD.
#
#----------------------------------------------------------------------

import os, commands, sys, sre, time, traceback, glob, signal, snack

#--- Parameters that will become command line options
LIVECD   = ''                                   # If true, the setup is executed for a LiveCD
                                                # If false, the setup is executed for an installation to HD
ASK_HA   = 'True'                               # If true, the script offers to configure an HA System
SIPXUSER = 'sipxchange'                         # User under which sipX runs

#--- Local constants and files

RECROOTDIR     = '/recovery'                       # Root directory of recovery partition
IFCONFIGDIR    = '/etc/sysconfig/network-scripts'  # Directory of all interface configurations
ETHNAME        = 'eth0'                            # Supported Ethernet interface
IFCFGFILE      = '%s/ifcfg-%s' % (IFCONFIGDIR, ETHNAME)
CONFIGDEFSFile = '/etc/sipxpbx/config.defs'
RUNLEVEL       = 3                                 # Always use this runlevel
SSL_GENDIR     = '/root/sipx-certdb'               # Directory where certificates are stored
SSL_CRTDIR     = '/etc/sipxpbx/ssl'                # Directory where certificates are installed
ALIASFILE      = '/etc/aliases'
DNSSYSCFGFILE  = '/etc/sysconfig/named'
TOPOLOGYFILE   = '/etc/sipxpbx/topology.xml.in'
PROCESS_D      = '/etc/sipxpbx/process.d/'
REGISTRARFILE  = '/etc/sipxpbx/registrar-config.in'
CDRCONFIG      = '/etc/sipxpbx/callresolver-config.in'
PROXYCONFIG    = '/etc/sipxpbx/proxy-config.in'
AUTHPROXYCONFIG= '/etc/sipxpbx/authproxy-config.in'
WATCHDOG_CONFIG= '/etc/sipxpbx/sipxsupervisor-config.in'

# -----------------------------------------------------------------------------------------------------------
# Global variables

global fout

# Settings variables

global AdminEmail
AdminEmail = ''

global AdminPassword
AdminPassword=''

global TimeZone
TimeZone=''

global NtpServers
NtpServers=[]

global HostName
HostName = ''

global DomainName
DomainName = ''

global SipDomain
SipDomain = ''

global IpAddress
IpAddress = ''

global NetMask
NetMask = ''

global Gateway
Gateway = ''

global DnsServers
DnsServers = []

global useDHCPServer
useDHCPServer = ''
global useDNSServer
useDNSServer = ''
global useNTPServer
useNTPServer = ''
global RedoAskServers
RedoAskServers = 0

global useHASystem
useHASystem = ''
global useMasterHASystem
useMasterHASystem = ''

global DistributedHostName
DistributedHostName = ''
global DistributedDomainName
DistributedDomainName = ''
global DistributedIpAddress
DistributedIpAddress = ''
global DistributedNetMask
DistributedNetMask = ''
global DistributedDnsServers
DistributedDnsServers = []

# logging utilities 
OUTPUT_LOG  = '/var/log/sipxpbx/setup.log'

def log_init ():
    global fout
    fout=open(OUTPUT_LOG,"w")

def log_printout (outString):
    global fout
    fout.write(outString + "\n")
    fout.flush()

def log_result (setting, value) :
    log_printout( '\t%-30s : %s' % ( setting, value ))

def log_close ():
    global fout
    fout.close

# screen handling utilities
global screen
global layout
global explain
global stepmsg
global progressbar

def screen_init ():
    global screen
    global stepmsg
    global progressbar
    global progressvalue

    screen = snack.SnackScreen()

    stepmsg = snack.Textbox(60, 1, "")

    progressvalue = 0
    progressbar = snack.Scale(60,100)

def page_setup (explainMsg):
    global screen
    global stepmsg
    global progressbar
    global progressvalue

    layout = snack.Grid(1, 4)

    explain = snack.TextboxReflowed(60, explainMsg, 3, 10)
    layout.setField(explain, 0, 0, (1,1,1,1))

    # the 0,1 item is the variablePart inserted by screen_setup

    layout.setField(progressbar, 0, 2, (1,1,1,1))

    layout.setField(stepmsg, 0, 3)

    return layout

def screen_setup (title, explainMsg, variablePart) :
    global screen
    global progressbar

    form = snack.Form()
    layout = page_setup(explainMsg)

    if variablePart != None :
        layout.setField(variablePart, 0, 1)

    form.add(layout)
    screen.gridWrappedWindow(layout, title)
    form.draw()

    progressbar.set(progressvalue)
    screen.refresh()
    return form

def screen_end () :
    global screen
    screen.popWindow()

def screen_err (errorMessage,buttonLabel="Redo"):
    global explain

    button=snack.Button(buttonLabel)
    form = screen_setup("Error", errorMessage, button)

    form.run()
    screen_end()


# error handling
def raiseCleanExit (outString):
    log_printout (outString)
    screen_err(outString, "Abort")
    screen.finish()
    raise SystemExit

# progress screen

def progress(percent,msg):
    global progressbar
    global progressvalue
    global stepmsg
    global screen

    log_printout("\n--- %d %s\n" % (percent, msg))
    progressvalue=percent
    stepmsg.setText(msg)

def show_progress() :
    f = screen_setup("", "", None)
    time.sleep(1)
    screen_end()

# timezone fuctions

ZONEDIR='/usr/share/zoneinfo'
ZONEINFO='/etc/localtime'
reZoneName=sre.compile('^[A-Z][a-zA-Z_0-9+-]+$')
reIsZoneData=sre.compile(': timezone data$')

def isZoneName (name) :
    return reZoneName.match(name) 

def isZoneDir (name) :
    return os.path.isdir(ZONEDIR+'/'+name)

def getZones (majorZone=None) :
    if majorZone == None :
        zoneDir=ZONEDIR
    else :
        zoneDir=ZONEDIR+'/'+majorZone
    zones=[]
    for obj in filter(isZoneName, os.listdir(zoneDir)) :
        objPath=zoneDir+'/'+obj
        if  isZoneDir(obj) or reIsZoneData.search(commands.getoutput ('file '+objPath)) :
            zones.append(obj)
    zones.sort()
    return zones


###############################################################
## Create a new xorg.conf file for LiveCD

def set_xorg_conf () :

    if LIVECD :
        log_printout ( '\n--- Configure xorg.conf for host system ---\n' )
        # "Xorg -configure" needs /dev/mouse, which is not available after default install
        cmds = [ 'ln -s /dev/input/mice /dev/mouse', 'Xorg -configure', 'mv /etc/X11/xorg.conf /etc/X11/xorg.conf.orig', \
                 'mv xorg.conf.new /etc/X11/xorg.conf' ]

        for i in range(len(cmds)) :
            cmdoutput=commands.getoutput(cmds[i])
            log_printout(cmdoutput)

###############################################################
## Convert decimal number to binary. Used to calculate NetMask number of '1' bits

def dec2bin(n) :
    binstr = ''
    if n < 0:  raise ValueError, "must be a positive integer"
    if n == 0: return '0'
    while n > 0:
        binstr = str(n % 2) + binstr
        n = n >> 1
    return binstr

def NetmaskNrBits(NetmaskString) :
    result = ''
    quadsplit = NetmaskString.split(".")

    for items in quadsplit :
        result = result + dec2bin(int(items))
    return result.count("1")


################################################################
# Settings collection scripts
################################################################

def check_prerequisites () :
    show_progress()

    # Root user should run this script
    if os.getenv ('LOGNAME') != 'root':
        raiseCleanExit ( 'You must be the "root" user to run this script' )
    log_result('Root user', 'Ok')

    #if not LIVECD :
        # Recovery partition should exist
        #if not os.path.exists (RECROOTDIR):
        #    raiseCleanExit ( 'Unable to locate the recovery partition: %s' % RECROOTDIR )
        #log_result('Recovery partition', 'Detected')

        # RPMS directory in recovery partition should exist
        #rpmDir      = commands.getoutput ('find %s -name RPMS' % RECROOTDIR)
        #if not rpmDir:
        #    raiseCleanExit ( 'Failed to locate RPMS directory in %s' % RECROOTDIR )
        #log_result('RPMS directory', 'Detected')


def screen_startup ():
   global explain

   initialMessage ='\
This wizard configures the basic system settings \
needed to start your system. Press <SPACE> to continue.'

   okButton = snack.Button("   OK   ")

   f = screen_setup("Setup Wizard", initialMessage, okButton)
   f.run()

   screen_end()


def screen_ask_HASystem ():

    global useHASystem

    if ASK_HA :

        HASystemMessage ="\
Do you want to configure a high-availability (HA) system ? \n\
Note: This requires two servers to be setup."

        grid = snack.Grid(2, 1)

        noHAButton = snack.Button("No HA System")
        grid.setField(noHAButton, 0, 0, (1,0,1,1))

        HAButton = snack.Button("HA System")
        grid.setField(HAButton, 1, 0, (1,0,1,1))

        form = screen_setup("Configure HA System", HASystemMessage, grid)
        choice = form.run()

        screen_end()

        if choice == HAButton :
            #--- Configure and enable HA System
            log_printout ( '\n--- Configure HA System selected ---\n' )
            useHASystem = 'True'

            # Determine whether this is the master or distributed
            screen_ask_MasterHASystem ()

        else :
            log_printout ( '\n--- No HA System selected ---\n' )
    else:
        log_printout ( '\n--- HA System config disabled ---\n' )


def screen_ask_MasterHASystem ():

    global useMasterHASystem

    HASystemMessage ="\
You selected to configure a high-availability (HA) system. \n\
The Master system will run all services, \n\
the Distributed system only redundant services."

    grid = snack.Grid(2, 1)

    MasterHAButton = snack.Button("Master HA System")
    grid.setField(MasterHAButton, 0, 0, (1,0,1,1))

    DistributedHAButton = snack.Button("Distributed HA System")
    grid.setField(DistributedHAButton, 1, 0, (1,0,1,1))

    form = screen_setup("Select Master or Distributed System", HASystemMessage, grid)
    choice = form.run()

    screen_end()

    if choice == MasterHAButton :
        #--- Configure and enable Master HA System
        log_printout ( '\n--- Configure Master HA System selected ---\n' )
        useMasterHASystem = 'True'

    else :
        log_printout ( '\n--- Configure Distributed HA System selected ---\n' )


def test_for_installed_Distributed_Certificate ():
# This function pauses the installation until the Distributed certificate has been remotely
# installed from the Master. It allows the admin to test whether the certificate 
# successfully arrived.

    if useHASystem and not useMasterHASystem :
        show_progress()

        DistributedCertMessage ="\
You must now install the SSL Certificates for this system\n\
by pushing them from the Master Server.\n\
\n\
Execute these commands as root on %s:\n\
\n\
cd ~/sipx-certdb\n\
/usr/bin/ssl-cert/install-cert.sh --remote %s" % ( DistributedHostName, HostName )

        valuesOk=0
        while valuesOk == 0 :
            grid = snack.Grid(2, 1)

            CertInstalledButton = snack.Button("Certificate Has Been Installed - Test and Proceed")
            grid.setField(CertInstalledButton, 0, 0, (1,0,1,1))

            form = screen_setup("Install Security Certificate", DistributedCertMessage, grid)
            choice = form.run()

            if choice == CertInstalledButton :
                #--- Test whether a certificate has been installed

                # check availability of the Distributed Certificate directory. This needs to be installed manually
                # from the master
                if not os.path.exists (SSL_CRTDIR):
                    screen_err("Install failed - directory '%s' does not exist" % SSL_CRTDIR)
                else :
                    log_result('Distributed Certificate directory', 'Detected')

                    # check for certificate files (we only test for two of the three files)
                    searchString = [ 'ca.*.crt', 'ssl.key', 'ssl.crt']
                    for i in range(len(searchString)) :
                        certFile      = commands.getoutput ('find %s -name %s' % (SSL_CRTDIR, searchString[i]))
                        if not certFile :
                            screen_err('Failed to locate certificates in %s' % SSL_CRTDIR)
                        else :
                            log_result('Certificate file %s' % certFile, 'Detected')
                            valuesOk=1

            screen_end()

    else :
        log_printout ( '\n--- Not a Distributed System - Certificate test skipped ---\n' )


def screen_ask_admin ():

   global AdminPassword
   global AdminEmail
   #global DomainName

   adminExplanation = "\
Choose a new admin password for the 'root' user.\n\
Admin email address receives system messages."

   okButton = snack.Button("   OK   ")

   valuesOk=0
   while valuesOk == 0 :
       sg = snack.Grid(3, 4)

       l1a = snack.Label("Admin Password:")
       e1a = snack.Entry(32, AdminPassword, 0, 1)
       sg.setField(l1a, 0, 0)
       sg.setField(e1a, 1, 0)

       l1b = snack.Label("Admin Password:")
       e1b = snack.Entry(32, AdminPassword, 0, 1)
       sg.setField(l1b, 0, 1)
       sg.setField(e1b, 1, 1)

       l2 = snack.Label("Admin email:")
       e2 = snack.Entry(32,  '' )
       sg.setField(l2, 0, 2)
       sg.setField(e2, 1, 2)

       sg.setField(okButton, 0, 3, (1,1,1,1), growx=1)

       sg.place(1,1)

       f = screen_setup("Administrator Settings", adminExplanation, sg)

       formaction = f.run()

       if e1a.value() != e1b.value() :
           screen_err("Admin Password values do not match")
       elif e2.value().count('@') < 1:
           screen_err("Admin email address invalid")
       else :
           AdminPassword = e1a.value()
           AdminEmail = e2.value()
           valuesOk=1

       screen_end()

   log_result("AdminPassword", "(not logged)")
   log_result("AdminEmail", AdminEmail)


def screen_ask_services ():
   global useDHCPServer
   global useDNSServer
   global useNTPServer

   serverMessage ='\
Additional services can be configured on the sipX host. \
Default setting is "ON" for all. \
Note: Only one DHCP server allowed per subnet.'

   if not useHASystem or useMasterHASystem :
       # Offer all services on the Master
       layout = snack.Grid(1, 4)
       CheckDHCP = snack.Checkbox("   DHCP Server   ", isOn = 1)
       CheckDNS = snack.Checkbox("   DNS Server    ", isOn = 1)
       CheckNTP = snack.Checkbox("   NTP Server    ", isOn = 1)
       okButton = snack.Button("   OK   ")
       layout.setField(CheckDNS, 0, 0, (1,0,1,0))
       layout.setField(CheckNTP, 0, 1, (1,0,1,0))
       layout.setField(CheckDHCP, 0, 2, (1,0,1,0))
       layout.setField(okButton, 0, 3, (1,1,1,1))

   else :
       # Do not offer to install DHCP on the Distributed
       layout = snack.Grid(1, 3)
       CheckDNS = snack.Checkbox("   DNS Server    ", isOn = 1)
       CheckNTP = snack.Checkbox("   NTP Server    ", isOn = 1)
       okButton = snack.Button("   OK   ")
       layout.setField(CheckDNS, 0, 0, (1,0,1,0))
       layout.setField(CheckNTP, 0, 1, (1,0,1,0))
       layout.setField(okButton, 0, 2, (1,1,1,1))


   f = screen_setup("Choosing Additional Services", serverMessage, layout)
   f.run()

   if not useHASystem or useMasterHASystem :
       useDHCPServer = CheckDHCP.selected()

   useDNSServer = CheckDNS.selected()
   useNTPServer = CheckNTP.selected()

   log_printout ( '\n--- Additional Services selected (DHCP/DNS/NTP Servers) ---\n' )
   if not useHASystem or useMasterHASystem :
       log_result('DHCP:',useDHCPServer)
   log_result('DNS: ',useDNSServer)
   log_result('NTP: ',useNTPServer)

   screen_end()


def screen_ask_net ():
   global HostName
   global DomainName
   global IpAddress
   global NetMask
   global Gateway
   global DnsServers
   global useDNSServer
   global RedoAskServers

   netExplanation='Configure network settings for this system:\n'

   valuesOk=0
   while valuesOk == 0 :
       sg = snack.Grid(3, 9)
       l0 = snack.Label(" ")

       l1 = snack.Label("Hostname:   ")
       e1 = snack.Entry(32, HostName)
       sg.setField(l1, 0, 0)
       sg.setField(e1, 1, 0)

       l2 = snack.Label("Ip:         ")
       e2 = snack.Entry(32, IpAddress)
       sg.setField(l2, 0, 1)
       sg.setField(e2, 1, 1)

       l3 = snack.Label("Netmask:    ")
       e3 = snack.Entry(32, NetMask)
       sg.setField(l3, 0, 2)
       sg.setField(e3, 1, 2)

       l4 = snack.Label("Gateway Address: ")
       e4 = snack.Entry(32, Gateway)
       sg.setField(l4, 0, 3)
       sg.setField(e4, 1, 3)

       if not useDNSServer :
           l5 = snack.Label("Nameserver 1 Address: ")
           e5 = snack.Entry(32, '')
           sg.setField(l5, 0, 4)
           sg.setField(e5, 1, 4)

           l6 = snack.Label("Nameserver 2 Address: ")
           e6 = snack.Entry(32, '')
           sg.setField(l6, 0, 5)
           sg.setField(e6, 1, 5)

       okButton = snack.Button("   OK   ")
       sg.setField(okButton, 0, 8, (1,1,1,1))

       sg.place(1,1)

       f = screen_setup("Enter the network settings", netExplanation, sg)
       f.run()

       HostName=e1.value().lower()
       IpAddress=e2.value()
       NetMask=e3.value()
       Gateway=e4.value()

       if useDNSServer :
           DnsServers = [ IpAddress, '' ]
       else:
           DnsServers = [ e5.value(), e6.value() ]

       screen_end()

       # Assume all entries OK, now check for errors
       valuesOk=1

       #--- validation
       if HostName.count('.') < 2:
           # We expect at least 2 dots in the new fully qualified host name
           valuesOk=0
           screen_err('"%s" is not a fully qualified host name' % HostName)
       else :
           # Domain name == whatever follows the first dot
           DomainName = '.'.join (HostName.split('.')[1:])

       if len(NetMask.split('.')) < 4:
           valuesOk=0
           screen_err('"%s" is not a valid Netmask' % NetMask)

       elif not (NetMask.split('.')[0] == '255' and NetMask.split('.')[1] == '255') :
           valuesOk=0
           screen_err('"%s" is not a valid Netmask.' % NetMask)
       else :
           for i in range(4):
               if not NetMask.split('.')[i] in ('255', '0', '128', '192', '224', '240', '248', '252', '254'):
                   valuesOk=0
                   screen_err('"%s" is not a valid Netmask' % NetMask)

       if IpAddress.count('.') < 3:
           # We expect at least 3 dots in an IP addr
           valuesOk=0
           screen_err('"%s" is not a valid IP addr' % IpAddress)

       addrLst = IpAddress.split('.')
       maskLst = NetMask.split('.')
       netwAddr  = '.'.join([str(int(addrLst[i]) & int(maskLst[i]))  for i in range(4)])
       broadAddr = '.'.join([str(int(addrLst[i]) | (255 - int(maskLst[i]))) for i in range(4)])
       if IpAddress == netwAddr or IpAddress == broadAddr :
           valuesOk=0
           screen_err('"%s, %s" is not a valid IP address / Netmask combination' % (IpAddress, NetMask))

       if Gateway.count('.') < 3:
           # We expect at least 3 dots in an IP addr
           valuesOk=0
           screen_err('"%s" is not a valid Gateway addr' % Gateway)

       GWaddrLst = Gateway.split('.')
       GWnetwAddr  = '.'.join([str(int(GWaddrLst[i]) & int(maskLst[i]))  for i in range(4)])
       if GWnetwAddr != netwAddr or Gateway == netwAddr or Gateway == broadAddr :
           valuesOk=0
           screen_err('"%s" is not a valid Gateway addr. It is not in the addr range defined by the Netmask / IP addr combination.' % Gateway)

       if not useDNSServer :
           if DnsServers[0].count('.') < 3:
               # We expect at least 3 dots in an IP addr
               valuesOk=0
               screen_err('"%s" is not a valid DNS addr' % DnsServers[0])

           if DnsServers[1] != '' and DnsServers[1].count('.') < 3:
               # We expect at least 3 dots in an IP addr
               valuesOk=0
               screen_err('"%s" is not a valid DNS addr' % DnsServers[1])

           if DnsServers[0] == IpAddress or DnsServers[1] == IpAddress :
               # DNS server points to the sipX host but DNS server is not enabled
               # Go back and ask the admin to reconsider selection of services
               RedoAskServers=0
               screen_err('DNS Server address points to this host, but no DNS Server is configured')

   if RedoAskServers == 1:
       log_result("HostName", HostName)
       log_result("DomainName", DomainName)
       log_result("IpAddress", IpAddress)
       log_result("NetMask", NetMask)
       log_result("Gateway", Gateway)
       log_result("DnsServers", DnsServers)


def screen_ask_net_Distributed ():
   global DistributedHostName
   global DistributedDomainName
   global DistributedIpAddress
   global DistributedNetMask
   global DistributedDnsServers
   global useDNSServer
   global RedoAskServers

   # Get networking info for the "other system". If configuring Distributed this is the Master
   if useMasterHASystem :
       otherSystemName = 'Distributed system'
   else :
       otherSystemName = 'Master system'

   netExplanation='Configure network settings for the %s:\n' % otherSystemName

   valuesOk=0
   while valuesOk == 0 :
       sg = snack.Grid(3, 9)
       l0 = snack.Label(" ")

       l1 = snack.Label(otherSystemName+" Hostname:    ")
       e1 = snack.Entry(32, DistributedHostName)
       sg.setField(l1, 0, 0)
       sg.setField(e1, 1, 0)

       l2 = snack.Label(otherSystemName+" IP:          ")
       e2 = snack.Entry(32, DistributedIpAddress)
       sg.setField(l2, 0, 1)
       sg.setField(e2, 1, 1)

       l3 = snack.Label(otherSystemName+" Netmask:     ")
       e3 = snack.Entry(32, DistributedNetMask)
       sg.setField(l3, 0, 2)
       sg.setField(e3, 1, 2)

       if not useDNSServer :
           l5 = snack.Label(otherSystemName+" Nameserver 1 Address: ")
           e5 = snack.Entry(32, '')
           sg.setField(l5, 0, 4)
           sg.setField(e5, 1, 4)

           l6 = snack.Label(otherSystemName+" Nameserver 2 Address: ")
           e6 = snack.Entry(32, '')
           sg.setField(l6, 0, 5)
           sg.setField(e6, 1, 5)

       okButton = snack.Button("   OK   ")
       sg.setField(okButton, 0, 8, (1,1,1,1))

       sg.place(1,1)

       f = screen_setup("Enter %s network settings" % otherSystemName, netExplanation, sg)
       f.run()

       DistributedHostName=e1.value()
       DistributedIpAddress=e2.value()
       DistributedNetMask=e3.value()

       if useDNSServer :
           DistributedDnsServers = [ DistributedIpAddress, '' ]
       else:
           DistributedDnsServers = [ e5.value(), e6.value() ]

       screen_end()

       # Assume all entries OK, now check for errors
       valuesOk=1

       #--- validation
       if DistributedHostName.count('.') < 2:
           # We expect at least 2 dots in the new fully qualified host name
           valuesOk=0
           screen_err('"%s" is not a fully qualified domain name' % HostName)
       else :
           # Domain name == whatever follows the first dot
           DistributedDomainName = '.'.join (DistributedHostName.split('.')[1:])

       if len(DistributedNetMask.split('.')) < 4:
           valuesOk=0
           screen_err('"%s" is not a valid Netmask' % DistributedNetMask)

       elif not (DistributedNetMask.split('.')[0] == '255' and DistributedNetMask.split('.')[1] == '255') :
           valuesOk=0
           screen_err('"%s" is not a valid Netmask.' % DistributedNetMask)
       else :
           for i in range(4):
               if not DistributedNetMask.split('.')[i] in ('255', '0', '128', '192', '224', '240', '248', '252', '254'):
                   valuesOk=0
                   screen_err('"%s" is not a valid Netmask' % DistributedNetMask)

       if DistributedIpAddress.count('.') < 3:
           # We expect at least 3 dots in an IP addr
           valuesOk=0
           screen_err('"%s" is not a valid IP addr' % DistributedIpAddress)

       addrLst = DistributedIpAddress.split('.')
       maskLst = DistributedNetMask.split('.')
       netwAddr  = '.'.join([str(int(addrLst[i]) & int(maskLst[i]))  for i in range(4)])
       broadAddr = '.'.join([str(int(addrLst[i]) | (255 - int(maskLst[i]))) for i in range(4)])
       if DistributedIpAddress == netwAddr or DistributedIpAddress == broadAddr :
           valuesOk=0
           screen_err('"%s, %s" is not a valid IP address / Netmask combination' % (DistributedIpAddress, DistributedNetMask))

       if not useDNSServer :
           if DistributedDnsServers[0].count('.') < 3:
               # We expect at least 3 dots in an IP addr
               valuesOk=0
               screen_err('"%s" is not a valid DNS addr' % DistributedDnsServers[0])

           if DistributedDnsServers[1] != '' and DistributedDnsServers[1].count('.') < 3:
               # We expect at least 3 dots in an IP addr
               valuesOk=0
               screen_err('"%s" is not a valid DNS addr' % DistributedDnsServers[1])

           if DistributedDnsServers[0] == DistributedIpAddress or DistributedDnsServers[1] == DistributedIpAddress :
               # DNS server points to the sipX host but DNS server is not enabled
               RedoAskServers=0
               screen_err('DNS Server address points to this host, but no DNS Server is configured')

           if DistributedDnsServers[0] == IpAddress or DistributedDnsServers[1] == IpAddress :
               # DNS server points to the sipX host but DNS server is not enabled
               RedoAskServers=0
               screen_err('DNS Server address points to the redundant host, but no DNS Server is configured')

           if DnsServers[0] == DistributedIpAddress or DnsServers[1] == DistributedIpAddress :
               # DNS server points to the sipX host but DNS server is not enabled
               RedoAskServers=0
               screen_err('DNS Server address points to the redundant host, but no DNS Server is configured')

       else :
       # Set the correct DNS server address now that we know the Distributed IP address
           DnsServers[1] = DistributedIpAddress
           DistributedDnsServers[1] = IpAddress

   if RedoAskServers == 1:
       log_result(otherSystemName+" HostName", DistributedHostName)
       log_result(otherSystemName+" DomainName", DistributedDomainName)
       log_result(otherSystemName+" IpAddress", DistributedIpAddress)
       log_result(otherSystemName+" NetMask", DistributedNetMask)
       log_result(otherSystemName+" DnsServers", DistributedDnsServers)


def screen_get_tz () :
    global TimeZone

    tzExplanationMajor='Select your continent.'

    majorZones=getZones()

    list=snack.Listbox(10,1,1,32)
    for zone in majorZones : list.append(zone,'%s'%zone)

    f = screen_setup("Time Zone", tzExplanationMajor, list)
    major = f.run().current()
    TimeZone=major
    screen_end()

    if isZoneDir(major) :
        minorZones=getZones(major)

        tzExplanationMinor='Select a city in your time zone.'

        minorList=snack.Listbox(10,1,1,32)
        for zone in minorZones : minorList.append(zone,major+'/'+zone)

        f = screen_setup("Time Zone", tzExplanationMinor, minorList)
        selection = f.run().current()
        TimeZone=selection
        screen_end()

    log_result("TimeZone",TimeZone)


def screen_ask_sip () :
    global SipDomain
    global DomainName

    reDomain=sre.compile('^[a-z0-9][a-z0-9-]*\.(([a-z0-9][a-z0-9-]*))')

    sipExplanation ="\
Your SIP Domain name is the name to the right\n\
of the '@' in your SIP addresses, like this:\n\
     sip:user@%s\n \n\
If just the domain name is used, add DNS SRV records." % DomainName

    valuesOk=0
    while valuesOk == 0 :

        inner = snack.Grid(2, 3)

        l1 = snack.Label("SIP Domain Name: ")

        # IF using an HA system, use the shorter of the domain names as the SIP domain
        # for both servers
        # Function screen_ask_net_Distributed() assured that they are equal if they
        # have equal length
        if useHASystem and (len(DistributedDomainName.split('.')) < len(DomainName.split('.'))) :
            e1 = snack.Entry(32, DistributedDomainName)
        else :
            e1 = snack.Entry(32, DomainName)

        inner.setField(l1, 0, 1)
        inner.setField(e1, 1, 1)

        okButton = snack.Button("   OK   ")
        inner.setField(okButton, 0, 2, (1,1,1,1))

        f = screen_setup("SIP Settings", sipExplanation, inner)

        f.run()

        SipDomain=e1.value()

        screen_end()

        # Test for valid SIP domain name
        if reDomain.search(SipDomain) :
            valuesOk = 1
        else :
            screen_err("Your SIP Domain must be at least two DNS labels separated by dots.")

    log_result("SipDomain", SipDomain)
   

def set_network ():
    """
    Sets a full host name in the /etc/sysconfig/network file.
    In addition this procedure in the SET mode puts a host name
    into /etc/hosts and a domain name into the /etc/resolv.conf file.
    """
    show_progress()

    # Create file: /etc/sysconfig/network
    file1 = '/etc/sysconfig/network'
    f1Cont = '\
NETWORKING=yes\n\
HOSTNAME=%s\n\
GATEWAY=%s\n\
' % ( HostName, Gateway )
    log_printout("======= %s:\n" % file1)
    log_printout(f1Cont)
    file (file1, 'w').write(f1Cont)

    # Rewrtie file: /etc/hosts
    file2 = '/etc/hosts'
    f2Cont  = '\
# Do not remove the following line, or various programs\n\
# that require network functionality will fail.\n\
127.0.0.1 localhost.localdomain localhost\n\
%s %s %s\n' % (IpAddress, HostName, HostName.split('.')[0]) #'
    log_printout("======= %s:\n" % file2)
    log_printout(f2Cont)
    file (file2, 'w').write(f2Cont)

    # Add domain name in the file: /etc/resolv.conf
    file3 = '/etc/resolv.conf'
    f3Cont = 'search %s\n' % DomainName
    f3Cont+='nameserver 127.0.0.1\n'
    for ns in DnsServers :
        if len(ns) > 0 :
            f3Cont+='nameserver %s\n' % ns
    log_printout("======= %s:\n" % file3)
    log_printout(f3Cont)
    file (file3, 'w').write(f3Cont)

    # Set hostname
    SETHOSTNAMECMD = 'hostname %s' % HostName
    cmdoutput=commands.getoutput(SETHOSTNAMECMD)
    log_printout(cmdoutput)


def set_netif () :
     """
     Updates the interface configuration file
     /etc/sysconfig/network-scripts/ifcfg-eth0 with the following parameters:
     BROADCAST, IPADDR, NETMASK, NETWORK
     """
     global IpAddress
     global NetMask
     global Gateway

     show_progress()

     # Read a configuration file for a first ethernet interface
     # (presumably /etc/sysconfig/network-scripts/ifcfg-eth0)
     try:
         ifcfgContents   = file (IFCFGFILE).read().strip()
     except:
         ifcfgContents   = ""

     # Get IP address and IP mask
     addrLst = IpAddress.split('.')
     maskLst = NetMask.split('.')

     # Construct network address
     netwAddr  = '.'.join([str(int(addrLst[i]) & int(maskLst[i]))  for i in range(4)])

     # Construct broadcast address
     broadAddr = '.'.join([str(int(addrLst[i]) | (255 - int(maskLst[i]))) for i in range(4)])

     reONBOOT    = sre.compile ('^ONBOOT=(\S*)', sre.M)   
     reIPADDR    = sre.compile ('^IPADDR=(\S*)', sre.M)
     reIPMASK    = sre.compile ('^NETMASK=(\S*)', sre.M)
     reBROAD     = sre.compile ('^BROADCAST=(\S*)', sre.M)
     reNETWORK   = sre.compile ('^NETWORK=(\S*)', sre.M)

     for reStr, key, val in [
         (reONBOOT,  'ONBOOT',    'YES'),
         (reIPADDR,  'IPADDR',    IpAddress),
         (reIPMASK,  'NETMASK',   NetMask),
         (reBROAD,   'BROADCAST', broadAddr),
         (reNETWORK, 'NETWORK',   netwAddr)]:
         if reStr.search (ifcfgContents):
             ifcfgContents = reStr.sub ('%s=%s' % (key, val), ifcfgContents)    # replace parameter ...
         else:
             ifcfgContents = ifcfgContents.strip () + '\n%s=%s' % (key, val)    # add parameter ...

     # Write a new content of the /etc/sysconfig/network-scripts/ifcfg-eth<n> file
     log_printout(ifcfgContents)
     file (IFCFGFILE, 'w').write(ifcfgContents)

     if LIVECD or useHASystem :
     # Network is needed to copy the certificate to the distributed host or on a LiveCD
        #restart the network
        RESTARTNETWORKCMD = 'service network restart'
        cmdoutput=commands.getoutput(RESTARTNETWORKCMD)
        log_printout(cmdoutput)


def set_admin_mail () :
    """
    Sets email address for root in /etc/aliases.
    """
    show_progress()

    reMAILADMIN   = sre.compile ('^root: (\S*)', sre.M) 
    NEWALIASCMD   = 'newaliases'

    f1Cont   = file (ALIASFILE).read()

    if reMAILADMIN.search (f1Cont):
        f1Cont = reMAILADMIN.sub ('root: %s' % AdminEmail, f1Cont)
    else:
        f1Cont = f1Cont.strip() + '\nroot: %s' % AdminEmail

    # Route messages to the sipxuser to root (e.g. watchdog alert emails)
    f1Cont += '\n'
    f1Cont += '# Error messages for SIPX user\n'
    f1Cont += '%s:        root \n' % SIPXUSER

    # Write a new content of the file /etc/aliases
    file (ALIASFILE, 'w').write(f1Cont)
    cmdoutput=commands.getoutput(NEWALIASCMD)
    log_printout(cmdoutput)


def set_password () :
    """Sets a new root password"""
    global AdminPassword

    show_progress()

    outRep = commands.getoutput ('echo "%s" | passwd --stdin root' % AdminPassword)
    log_printout(outRep)

    if outRep.find('updated successfully') < 0:
        raiseCleanExit ( 'Failed to set the root password' )

def screen_set_time() :

    grid=snack.Grid(6,4)

    timeExplanation="\
Select the date and time; Hours are 00-23.\n\
Use the up and down arrow keys to increment and decrement each field; tab between fields.\
"
    dateLabel=snack.Label("Date (year-month-day)")
    grid.setField(dateLabel,0,0)

    year=snack.Listbox(1,0,0,4,0)
    year.append("2010","2010")
    year.append("2009","2009")
    year.append("2008","2008")
    year.append("2007","2007")
    year.append("2006","2006")
    year.setCurrent("2008")
    grid.setField(year,1,0)

    y2mLabel=snack.Label("-")
    grid.setField(y2mLabel,2,0)

    month=snack.Listbox(1,0,0,2,0)
    month.append("12","12")
    month.append("11","11")
    month.append("10","10")
    month.append("09","09")
    month.append("08","08")
    month.append("07","07")
    month.append("06","06")
    month.append("05","05")
    month.append("04","04")
    month.append("03","03")
    month.append("02","02")
    month.append("01","01")
    month.setCurrent("01")
    grid.setField(month,3,0)

    m2dLabel=snack.Label("-")
    grid.setField(m2dLabel,4,0)

    day=snack.Listbox(1,0,0,2,0)
    day.append("31","31")
    day.append("30","30")
    day.append("29","29")
    day.append("28","28")
    day.append("27","27")
    day.append("26","26")
    day.append("25","25")
    day.append("24","24")
    day.append("23","23")
    day.append("22","22")
    day.append("21","21")
    day.append("20","20")
    day.append("19","19")
    day.append("18","18")
    day.append("17","17")
    day.append("16","16")
    day.append("15","15")
    day.append("14","14")
    day.append("13","13")
    day.append("12","12")
    day.append("11","11")
    day.append("10","10")
    day.append("09","09")
    day.append("08","08")
    day.append("07","07")
    day.append("06","06")
    day.append("05","05")
    day.append("04","04")
    day.append("03","03")
    day.append("02","02")
    day.append("01","01")
    day.setCurrent("01")
    grid.setField(day,5,0)

    timeLabel=snack.Label("Time (hour:minute)")
    grid.setField(timeLabel,0,1)

    hour=snack.Listbox(1,0,0,2,0)
    hour.append("23","23")
    hour.append("22","22")
    hour.append("21","21")
    hour.append("20","20")
    hour.append("19","19")
    hour.append("18","18")
    hour.append("17","17")
    hour.append("16","16")
    hour.append("15","15")
    hour.append("14","14")
    hour.append("13","13")
    hour.append("12","12")
    hour.append("11","11")
    hour.append("10","10")
    hour.append("09","09")
    hour.append("08","08")
    hour.append("07","07")
    hour.append("06","06")
    hour.append("05","05")
    hour.append("04","04")
    hour.append("03","03")
    hour.append("02","02")
    hour.append("01","01")
    hour.append("00","00")
    hour.setCurrent("12")
    grid.setField(hour,1,1)

    h2mLabel=snack.Label(":")
    grid.setField(h2mLabel,2,1)

    minute=snack.Listbox(1,0,0,2,0)
    minute.append("59","59")
    minute.append("58","58")
    minute.append("57","57")
    minute.append("56","56")
    minute.append("55","55")
    minute.append("54","54")
    minute.append("53","53")
    minute.append("52","52")
    minute.append("51","51")
    minute.append("50","50")
    minute.append("49","49")
    minute.append("48","48")
    minute.append("47","47")
    minute.append("46","46")
    minute.append("45","45")
    minute.append("44","44")
    minute.append("43","43")
    minute.append("42","42")
    minute.append("41","41")
    minute.append("40","40")
    minute.append("39","39")
    minute.append("38","38")
    minute.append("37","37")
    minute.append("36","36")
    minute.append("35","35")
    minute.append("34","34")
    minute.append("33","33")
    minute.append("32","32")
    minute.append("31","31")
    minute.append("30","30")
    minute.append("29","29")
    minute.append("28","28")
    minute.append("27","27")
    minute.append("26","26")
    minute.append("25","25")
    minute.append("24","24")
    minute.append("23","23")
    minute.append("22","22")
    minute.append("21","21")
    minute.append("20","20")
    minute.append("19","19")
    minute.append("18","18")
    minute.append("17","17")
    minute.append("16","16")
    minute.append("15","15")
    minute.append("14","14")
    minute.append("13","13")
    minute.append("12","12")
    minute.append("11","11")
    minute.append("10","10")
    minute.append("09","09")
    minute.append("08","08")
    minute.append("07","07")
    minute.append("06","06")
    minute.append("05","05")
    minute.append("04","04")
    minute.append("03","03")
    minute.append("02","02")
    minute.append("01","01")
    minute.append("00","00")
    minute.setCurrent("00")
    grid.setField(minute,3,1)

    okButton = snack.Button("OK")
    grid.setField(okButton,0,2,(1,1,1,1))

    f = screen_setup("Set Date/Time", timeExplanation, grid)
    f.run()

    dateCmd="date --set='%s-%s-%s %s:%s'" % (year.current(),month.current(),day.current(),hour.current(),minute.current())
    log_printout("Setting date/time: "+dateCmd)
    cmdoutput=commands.getoutput(dateCmd)
    log_printout(cmdoutput)

    screen_end()


def screen_ask_ssl ():
    """
    This procedure collects data needed for the ssl certificate
    Certificates are generated on the Master server
    and sent to the Distributed server manually
    """

    global Hostname
    global SipDomain

    if not useHASystem or useMasterHASystem :

        okButton = snack.Button("OK")

        ## The gen-ssl-keys.sh script accepts the following variables in a file for
        ## configuring the certificate parameters:
        ##
        ## countryName              Country Name (2 letter code) 
        ## stateOrProvinceName      State or Province Name (full name) 
        ## localityName             Locality Name (eg, city) 
        ## organizationName         Organization Name (eg, company) 
        ## organizationalUnitName   Organization Unit Name (eg, section)     VoIP Services
        ## caName                   CA Common Name (DNS name for CA)         ca.`hostname --domain` 
        ## caEmail                  Email Contact Address for CA             root@${caName}
        ## sipDomainName            SIP domain name                          `hostname --domain` 
        ## server                   Full DNS name for the server             `hostname --fqdn`
        ## server Server            Common Name (DNS name for Server)        `hostname --fqdn`
        ## serverEmail              Email Contact Address for Server         ${caEmail}
        ##
        ## we will prompt for a subset of the above, and use defaults for the rest

        securityExplanation='\
These parameters are used to build the self-signed TLS/SSL certificate that identifies this server.\n\
Note: Country Code:  2 letter code for your country (e.g. US)'

        valuesOk=0
        while valuesOk == 0 :
            sg = snack.Grid(2, 6)

            l2 = snack.Label("Organization Name: ")
            e2 = snack.Entry(32, "")
            sg.setField(l2, 0, 0)
            sg.setField(e2, 1, 0)

            l3 = snack.Label("Section Name:      ")
            e3 = snack.Entry(32, "VoIP Services")
            sg.setField(l3, 0, 1)
            sg.setField(e3, 1, 1)

            l4 = snack.Label("Country Code:      ")
            e4 = snack.Entry(32, "")
            sg.setField(l4, 0, 2)
            sg.setField(e4, 1, 2)

            l5 = snack.Label("State or Province: ")
            e5 = snack.Entry(32, "")
            sg.setField(l5, 0, 3)
            sg.setField(e5, 1, 3)

            l6 = snack.Label("Locality (city):   ")
            e6 = snack.Entry(32, "")
            sg.setField(l6, 0, 4)
            sg.setField(e6, 1, 4)

            sg.setField(okButton, 0, 5, (1,1,1,1) )

            f = screen_setup("TLS/SSL Security Parameters", securityExplanation, sg)
            choice = f.run()

            # TODO: should validate here
            if choice == okButton :
                valuesOk=1

            if len(e2.value()) == 0 :
                valuesOk=0
                screen_err('You must specify an Organization Name (may be any name)')

            if len(e3.value()) == 0 :
                valuesOk=0
                screen_err('You must specify a Section Name (may be any name)')

            if len(e4.value()) != 2 :
                valuesOk=0
                screen_err('"%s" is not a valid Country Code (must be exactly 2 letters)' % e4.value())

            if len(e5.value()) == 0 :
                valuesOk=0
                screen_err('You must specify a State or Province (may be any name)')

            if len(e6.value()) == 0 :
                valuesOk=0
                screen_err('You must specify a Locality (may be any name)')

            screen_end()

        # we have all the parameters now, so create the defaults file for the script

        curDir = os.getcwd ()
        if not os.path.exists (SSL_GENDIR) :
            cmdoutput=commands.getoutput ('mkdir -p %s' % SSL_GENDIR)
            log_printout (cmdoutput)

        os.chdir (SSL_GENDIR)

        # Save parameters to generate the keys and certificates
        defaults = ''
        defaults +='countryName="%s"\n' %  e4.value()
        defaults +='stateOrProvinceName="%s"\n' % e5.value()
        defaults +='localityName="%s"\n' % e6.value()
        defaults +='organizationName="%s"\n' % e2.value()
        defaults +='organizationalUnitName="%s"\n' % e3.value()
        defaults +='caName="ca.%s"\n' % HostName
        defaults +='caEmail="%s"\n' % AdminEmail
        defaults +='sipDomainName="%s"\n' % SipDomain
        defaults +='server="%s"\n' % HostName
        defaults +='serverEmail="%s"\n' % AdminEmail

        log_printout(defaults)

        file ( 'SSL_DEFAULTS', 'w').write( defaults )
 
        os.chdir (curDir)

def generate_ssl_cert () :

    if not useHASystem or useMasterHASystem :
        show_progress()

        curDir = os.getcwd ()
        os.chdir (SSL_GENDIR)

        genSsl      = '/usr/bin/ssl-cert/gen-ssl-keys.sh -d'

        cmdoutput=commands.getoutput (genSsl)
        log_printout (cmdoutput)

        if useMasterHASystem :
            # Change the server parameter in the SSL_DEFAULTS file to Distributed Host Name
            defaults   = file ('SSL_DEFAULTS').read().strip()

            if defaults.find('server=') > 0 :
                defaults = defaults.replace(('server=\"%s\"' % HostName), ('server=\"%s\"' % DistributedHostName), 1)
                file ( 'SSL_DEFAULTS', 'w').write( defaults )

            # Generate the certificate request for the Distributed system
            genSsl      = '/usr/bin/ssl-cert/gen-ssl-keys.sh -d --csr'
            cmdoutput=commands.getoutput (genSsl)
            log_printout (cmdoutput)

            # Generate the certificate for the Distributed by signing it
            genSsl      = 'echo "yes" | /usr/bin/ssl-cert/gen-ssl-keys.sh --sign %s.csr' % DistributedHostName  
            cmdoutput=commands.getoutput (genSsl)
            log_printout (cmdoutput)

        os.chdir (curDir)

def install_ssl_cert () :

    show_progress()
    curDir = os.getcwd ()

    if not useHASystem or useMasterHASystem :
        os.chdir (SSL_GENDIR)
#    else :
#        os.chdir ('Distributed-CRT')

        instSsl     = '/usr/bin/ssl-cert/install-cert.sh %s' % HostName

        # Install the new SSL certificate
        cmdoutput=commands.getoutput (instSsl)
        log_printout (cmdoutput)
        os.chdir (curDir)


def set_ntp () :

    global useNTPServer

    if useNTPServer :
        """Procedure to (re)configure NTP"""
        show_progress()

    #--- Create /etc/ntp.conf
    # Calculate subnet address based on the NetMask
    addrLst = IpAddress.split('.')
    maskLst = NetMask.split('.')

    # Construct network address. NetMask has already been checked and is valid
    Subnet  = '.'.join([str(int(addrLst[i]) & int(maskLst[i]))  for i in range(4)])

    # Define list of servers for time synchronization
    NTPSRVLST = ['0.pool.ntp.org', '1.pool.ntp.org' ]

    if useHASystem :
        # A Distributed system will also attempt to sync with the other
        NTPSRVLST.append(DistributedHostName)

    ntpConf  =  '# ntpd configuration\n'
    ntpConf  += '# ------------------\n'
    ntpConf  += '#\n'
    ntpConf  += '# Permit time synchronization with our time source, but do not'
    ntpConf  += '# permit the source to query or modify the service on this system.'
    ntpConf  += 'restrict default kod nomodify notrap nopeer noquery'
    ntpConf  += 'restrict -6 default kod nomodify notrap nopeer noquery'
    ntpConf  += '#\n'
    ntpConf  += '# Permit all access over the loopback interface\n'
    ntpConf  += 'restrict 127.0.0.1\n'
    ntpConf  += '#\n'
    ntpConf  += '# Local fudge if network servers are not available\n'
    ntpConf  += 'server 127.127.1.0\n'
    ntpConf  += 'fudge  127.127.1.0 stratum 10\n'
    ntpConf  += '#\n'
    ntpConf  += '#ntp reports in syslog that authenticate is invalid keyword\n'
    ntpConf  += '#authenticate no\n'
    ntpConf  += '#\n'
    ntpConf  += 'driftfile /var/lib/ntp/drift\n'
    ntpConf  += '# Synchronize with selected time servers\n'
    for nsvr in NTPSRVLST :
        ntpConf  += 'server %s\n' % nsvr

    log_printout(ntpConf)

    if useNTPServer :
        file ('/etc/ntp.conf', 'w').write ('%s\n' % ntpConf)

        #--- Create /etc/ntp/step-tickers
        file ('/etc/ntp/step-tickers', 'w').write ('\n'.join (NTPSRVLST))

        #--- Remove /etc/ntp/ntpservers
        try:    os.remove ('/etc/ntp/ntpservers')
        except: pass

        #--- Turn on the ntpd service on runlevel 3

        if LIVECD :
            cmdoutput=commands.getoutput ('service ntpd restart')
            log_printout (cmdoutput)
            log_printout('NTP Server configuration file written and service started')

        cmdoutput=commands.getoutput ('/sbin/chkconfig --level %d ntpd on' % RUNLEVEL)
        log_printout('NTP service enabled in runlevel')

    else :
        log_printout('NTP Server configuration written to logfile only. Service not enabled.')

def set_timezone () :
    global TimeZone

    sysconfig_clock='\
ZONE="%s"\n\
UTC=true\n' % TimeZone
    log_printout(sysconfig_clock)
    file('/etc/sysconfig/clock','w').write(sysconfig_clock)

    cmdoutput=''
    if os.path.exists(ZONEINFO) :
        cmdoutput=commands.getoutput('rm -rf '+ZONEINFO)

    cmdoutput+=commands.getoutput('ln -vs %s/%s %s' % (ZONEDIR, TimeZone, ZONEINFO))
    log_printout(cmdoutput)


def set_dhcpd () :
    # Currently there is only one DHCP server on the Master host configured. The max
    # lease time is 12 hours (43200 seconds). If the Master server is down for
    # longer than that, phones will loose their IP address leases.
    # Failover is possible running two DHCP servers on the same subnet. A good
    # description is here: http://www.madboa.com/geek/dhcp-failover/

    global useDHCPServer

    if useDHCPServer :
        show_progress()
        dhcpConfigFile='/etc/dhcpd.conf'

    # If DHCP not set still create configuration and write to log file
    #
    # Calculate subnet address based on the NetMask
    # NetMask has already been checked and is valid

    addrLst = IpAddress.split('.')
    maskLst = NetMask.split('.')

    # Construct subnet address
    SubnetLst = [str(int(addrLst[i]) & int(maskLst[i]))  for i in range(4)]
    Subnet  = '.'.join(SubnetLst)

    # The DHCP range is set to the full range of the subnet excluding broadcast address and the first address
    rangeStart =  '.'.join (SubnetLst[:3]) + '.' + str( int(SubnetLst[3]) +1 )
    rangeEndLst   =  [str(int(addrLst[i]) | (255 - int(maskLst[i]))) for i in range(4)]
    rangeEndLst[3]   = str( int(rangeEndLst[3]) - 1 )
    rangeEnd   = '.'.join (rangeEndLst) 

    # Create dhcpd.conf file entries
    dhcpdConf = ''
    dhcpdConf +='authoritative;\n'
    dhcpdConf +='ddns-update-style  none;\n \n'
    dhcpdConf +='subnet %s netmask %s {\n' % (Subnet, NetMask)
    dhcpdConf +='   range                        %s  %s;\n' % (rangeStart, rangeEnd)
    dhcpdConf +='   default-lease-time           21600;\n'
    dhcpdConf +='   max-lease-time               43200;\n'
    dhcpdConf +='   option routers               %s;\n' % Gateway
    dhcpdConf +='   option subnet-mask           %s;\n' % NetMask
    dhcpdConf +='   option domain-name           "%s";\n' % DomainName
    if DnsServers[1] == '':
        dhcpdConf +='   option domain-name-servers   %s;\n' % DnsServers[0]
    else :
        dhcpdConf +='   option domain-name-servers   %s, %s;\n' % (DnsServers[0], DnsServers[1])
    dhcpdConf +='   option tftp-server-name      "%s";\n' % HostName
    if useNTPServer :
        dhcpdConf +='   option ntp-servers           %s;\n' % IpAddress
    dhcpdConf +='}\n'

    log_printout(dhcpdConf)

    if useDHCPServer :
        file ( dhcpConfigFile, 'w').write( dhcpdConf )

        if LIVECD :
            #Start DHCP Server (dhcpd)
            STARTSIPXCMD = 'service dhcpd restart'
            cmdoutput=commands.getoutput(STARTSIPXCMD)
            log_printout(cmdoutput)
            log_printout('DHCP Server configuration file written and service started')

        cmdoutput=commands.getoutput ('/sbin/chkconfig --level %d dhcpd on' % RUNLEVEL)
        log_printout('DHCP service enabled in runlevel')
    else :
        log_printout('DHCP Server configuration written to logfile only. Service not enabled.')


def set_dns () :
    # This function configures a DNS server. The following three cases are possible:
    #  a) non HA system:  A Master DNS server is configured on the sipX host
    #  b) HA Master system: A Master DNS server is configured on the Master sipX host.
    #     For redundancy to work it is required to have a Distributed DNS server on the
    #     Distributed sipX host. If there is a DHCP server on the Master as well
    #     then the DHCP server needs to serve both DNS server addresses to clients (e.g. phones)
    #  c) HA Distributed system: A Distributed DNS server is configured. The script verifies
    #     that if the DNS server address points to the Master sipX host, a Distributed DNS
    #     server is required on the Distributed sipX host

    global useDNSServer

    show_progress()

    dnsConfigFile='/etc/named.conf'

    if useDNSServer :
        # Calculate subnet address based on the NetMask
        addrLst = IpAddress.split('.')
        maskLst = NetMask.split('.')

        # Construct network address. NetMask has already been checked and is valid
        SubnetLst  = [str(int(addrLst[i]) & int(maskLst[i]))  for i in range(4)]
        Subnet  = '.'.join(SubnetLst)

        # Construct reverse Subnet string for PTR zone file name
        # Calculate length
        if int(NetMask.split('.')[3]) != 0 :
            ii = 4
        elif int(NetMask.split('.')[2]) != 0 :
            ii = 3
        else :
            ii = 2
        # Invert string
        arpaReverseLst = ['', '', '', '']
        for i in range(ii) :
            arpaReverseLst[i] = SubnetLst[ii - i -1]

        if not NetmaskNrBits(NetMask) in (24, 16) :
            # Add the netmask in the format /xx
            arpaReverseLst[0] += '/'
            arpaReverseLst[0] += str(NetmaskNrBits(NetMask))

        reverseArpa = '.'.join (arpaReverseLst[:ii])

        # Calculate PTR for host
        if maskLst[2] == '255' :
            myHostPTR = addrLst[3]
        else :
            myHostPTR = '.'.join([addrLst[3], addrLst[2] ])

        if useHASystem :

            # Calculate subnet address based on the NetMask
            DistributedAddrLst = DistributedIpAddress.split('.')
            DistributedMaskLst = DistributedNetMask.split('.')

            # Construct network address. NetMask has already been checked and is valid
            DistributedSubnetLst  = [str(int(DistributedAddrLst[i]) & int(DistributedMaskLst[i]))  for i in range(4)]
            DistributedSubnet  = '.'.join(DistributedSubnetLst)

            # Construct reverse Subnet string for PTR zone file name
            # Calculate length
            if int(DistributedNetMask.split('.')[3]) != 0 :
                ii = 4
            elif int(DistributedNetMask.split('.')[2]) != 0 :
                ii = 3
            else :
                ii = 2
            # Invert string
            arpaReverseLst = ['', '', '', '']
            for i in range(ii) :
                arpaReverseLst[i] = DistributedSubnetLst[ii - i - 1]

            if not NetmaskNrBits(DistributedNetMask) in (24, 16) :
                # Add the netmask in the format /xx
                arpaReverseLst[0] += '/'
                arpaReverseLst[0] += str(NetmaskNrBits(DistributedNetMask))

            DistributedReverseArpa = '.'.join (arpaReverseLst[:ii])

            # Calculate PTR for host
            if DistributedMaskLst[2] == '255' :
                DistributedMyHostPTR = DistributedAddrLst[3]
            else :
                DistributedMyHostPTR = '.'.join([DistributedAddrLst[3], DistributedAddrLst[2] ])

        if not useHASystem or useMasterHASystem :
            # This is a non-HA or HA Master system. A Master DNS Server configuration is required

            # Create named.conf file entries
            namedConf = ''
            namedConf +='options { \n'
            namedConf += '    directory  "/var/named";\n'
            namedConf += '    dump-file "/var/named/data/cache_dump.db";\n'
            namedConf += '    statistics-file "/var/named/data/named_stats.txt";\n'
            namedConf +='};\n \n'
            namedConf +='zone "%s"  IN  {\n' % DomainName
            namedConf +='     type master;\n'
            namedConf +='     file "%s.zone";\n' % DomainName
            namedConf +='     allow-update { none; };\n'
            namedConf +='};\n'
            namedConf +='\n'
            namedConf +='zone "%s.IN-ADDR.ARPA"  {\n' % reverseArpa
            namedConf +='     type master;\n'
            namedConf +='     file "%s.zone";\n' % Subnet
            namedConf +='};\n\n'
            if useHASystem and (reverseArpa != DistributedReverseArpa) :
                namedConf +='zone "%s.IN-ADDR.ARPA"  {\n' % DistributedReverseArpa
                namedConf +='     type master;\n'
                namedConf +='     file "%s.zone";\n' % DistributedSubnet
                namedConf +='};\n\n'

        else :
            # This is an HA Distributed system and we configure a Distributed DNS server
            # Create named.conf file entries
            namedConf = ''
            namedConf +='options { \n'
            namedConf += '    directory  "/var/named";\n'
            namedConf += '    dump-file "/var/named/data/cache_dump.db";\n'
            namedConf += '    statistics-file "/var/named/data/named_stats.txt";\n'
            namedConf +='};\n \n'
            namedConf +='zone "%s"  IN  {\n' % DomainName
            namedConf +='     type slave;\n'
            namedConf +='     file "%s.zone";\n' % DomainName
            namedConf +='     masters { %s; };\n' % DistributedIpAddress
            namedConf +='};\n'
            namedConf +='\n'
            namedConf +='zone "%s.IN-ADDR.ARPA"  {\n' % reverseArpa
            namedConf +='     type slave;\n'
            namedConf +='     file "%s.zone";\n' % Subnet
            namedConf +='     masters { %s; };\n' % DistributedIpAddress
            namedConf +='};\n\n'
            if useHASystem and (reverseArpa != DistributedReverseArpa) :
                namedConf +='zone "%s.IN-ADDR.ARPA"  {\n' % DistributedReverseArpa
                namedConf +='     type slave;\n'
                namedConf +='     file "%s.zone";\n' % DistributedSubnet
                namedConf +='     masters { %s; };\n' % DistributedIpAddress
                namedConf +='};\n\n'

        if LIVECD :
        # named.rfc1912.zones files is provided by the RPM caching-nameserver > 9.x (not available on RHEL4)
            namedConf +='# Include zones for localhost and localdomain\n'
            namedConf +='include "/etc/named.rfc1912.zones";\n'

    else:
        # Set up a caching-only name server.
        # Create named.conf file entries
        namedConf = ''
        namedConf += '// Default "Caching Only" name server configuration\n'
        namedConf += '//\n\n'

        namedConf += 'options {\n'
        namedConf += '        directory "/var/named";\n'
        namedConf += '        dump-file "/var/named/data/cache_dump.db";\n'
        namedConf += '        statistics-file "/var/named/data/named_stats.txt";\n'
        namedConf += '        forwarders {\n'
        namedConf += '                %s;\n' % DnsServers[0]
        if DnsServers[1] != '' :
            namedConf += '                %s;\n' % DnsServers[1]
        namedConf += '        };\n'
        namedConf += '        forward only;\n'
        namedConf += '};\n\n'

    file ( dnsConfigFile, 'w').write( namedConf )
    log_printout('DNS Server configuration file %s written' % dnsConfigFile)
    log_printout(dnsConfigFile)
    log_printout(namedConf)

    if useDNSServer :
        if not useHASystem or useMasterHASystem : 
            # Zone files are only required for a Master DNS server.
            # A Master DNS server is used for a non HA setup or on a HA Master host

            dnsConfigFile='/var/named/%s.zone' % DomainName
            myHost = HostName.split('.')[0]

            # Create sipX specific DNS entries using the sipx-dns script provided for HA config
            if useHASystem :
                sipxDNSCommand = 'sipx-dns %s %s/%s %s/%s' % (DomainName, HostName, IpAddress, DistributedHostName, DistributedIpAddress)
            else :
                sipxDNSCommand = 'sipx-dns %s %s/%s' % (DomainName, HostName, IpAddress)

            sipxDNSEntries = commands.getoutput(sipxDNSCommand)

            namedConf = ''
            namedConf +='$TTL 1D\n'
            namedConf +='@       IN      SOA    ns1.%s.  root.%s. ( \n' % (DomainName, DomainName)
            namedConf +='                       200602132       ; serial#\n'
            namedConf +='                       3600            ; refresh, seconds\n'
            namedConf +='                       3600            ; retry, seconds\n'
            namedConf +='                       3600            ; expire, seconds\n'
            namedConf +='                       3600 )          ; minimum TTL, seconds\n'
            namedConf +='                NS     ns1.%s.   ; Inet Address of nameserver\n' % DomainName
            namedConf +='%s.     MX     10 mail           ; Primary Mail Exchanger\n' % DomainName
            namedConf +='\n'
            namedConf +='ns1             CNAME  %s\n' % myHost
            namedConf +='mail            CNAME  %s\n' % myHost
            namedConf +='\n'
            namedConf += sipxDNSEntries
            namedConf +='\n'

            log_printout(dnsConfigFile)
            log_printout(namedConf)
            file ( dnsConfigFile, 'w').write( namedConf )
            log_printout('DNS Server configuration file %s written' % dnsConfigFile)

            dnsConfigFile='/var/named/%s.zone' % Subnet
            myHostAddr = IpAddress.split('.')[3]

            namedConf = ''
            namedConf +='$TTL 1D\n'
            namedConf +='@       IN      SOA    ns1.%s.  root.%s. ( \n' % (DomainName, DomainName)
            namedConf +='                       200602132       ; serial#\n'
            namedConf +='                       3600            ; refresh, seconds\n'
            namedConf +='                       3600            ; retry, seconds\n'
            namedConf +='                       3600            ; expire, seconds\n'
            namedConf +='                       3600 )          ; minimum TTL, seconds\n'
            namedConf +='                NS     ns1.%s.   ; Inet Address of nameserver\n' % DomainName
            namedConf +='\n'
            namedConf +='%s      IN  PTR      %s.     ; Record of class IN by default\n' % (myHostPTR, HostName)
            if useHASystem and (reverseArpa == DistributedReverseArpa) :
                namedConf +='%s      IN  PTR      %s.     ; Record of class IN by default\n' % (DistributedMyHostPTR, DistributedHostName)
            namedConf +='\n'

            log_printout(dnsConfigFile)
            log_printout(namedConf)
            file ( dnsConfigFile, 'w').write( namedConf )
            log_printout('DNS Server configuration file %s written' % dnsConfigFile)

            if useHASystem and (reverseArpa != DistributedReverseArpa) :

                dnsConfigFile='/var/named/%s.zone' % DistributedSubnet
                DistributedmyHostAddr = DistributedIpAddress.split('.')[3]

                namedConf = ''
                namedConf +='$TTL 1D\n'
                namedConf +='@       IN      SOA    ns1.%s.  root.%s. ( \n' % (DistributedDomainName, DistributedDomainName)
                namedConf +='                       200602132       ; serial#\n'
                namedConf +='                       3600            ; refresh, seconds\n'
                namedConf +='                       3600            ; retry, seconds\n'
                namedConf +='                       3600            ; expire, seconds\n'
                namedConf +='                       3600 )          ; minimum TTL, seconds\n'
                namedConf +='                NS     ns1.%s.   ; Inet Address of nameserver\n' % DomainName
                namedConf +='\n'
                namedConf +='%s      IN  PTR      %s.     ; Record of class IN by default\n' % (DistributedMyHostPTR, DistributedHostName)
                namedConf +='\n'

                log_printout(dnsConfigFile)
                log_printout(namedConf)
                file ( dnsConfigFile, 'w').write( namedConf )
                log_printout('DNS Server configuration file %s written' % dnsConfigFile)


    # Now enable the configuration
    # Change ownership of zone files
    STARTSIPXCMD = 'chown -R named:named /var/named'
    cmdoutput=commands.getoutput(STARTSIPXCMD)
    log_printout(cmdoutput)

#    #Modify /etc/sysconfig/named to allow for zone file write access during dynamic update
#    try:
#        syscfgContents   = file (DNSSYSCFGFILE).read().strip()
#    except:
#        syscfgContents   = ""
#
#    syscfgContents +='\nENABLE_ZONE_WRITE=yes\n'
#    log_printout(DNSSYSCFGFILE)
#    log_printout(syscfgContents)
#    file ( DNSSYSCFGFILE, 'w').write( syscfgContents )

    # fix rndc.conf for CentOS 4.4
    if useDNSServer :
        fix_DNS_on_CentOS4 ()

#    if LIVECD :
    #Start DNS Server (named)
    STARTSIPXCMD = 'service named restart'
    cmdoutput=commands.getoutput(STARTSIPXCMD)
    log_printout(cmdoutput)
    log_printout('DNS Server configuration file written and service started')
#    else :
    cmdoutput=commands.getoutput ('/sbin/chkconfig --level %d named on' % RUNLEVEL)
    log_printout('DNS service enabled in runlevel')

def set_SIPDomain () :
    # Configure the SIP Domain and Realm
    # The SIP Domain setting is used to generate the proper certificate and 
    # we need to configure SIPXCHANGE_DOMAIN_NAME setting in /etc/config.defs

    global SipDomain

    show_progress()
    log_printout ( '\n--- Configuring SIP Domainname ---\n' )

    # Configure /etc/sipxpbx/config.defs
    try:
        configdefsContents   = file (CONFIGDEFSFile).read().strip()
    except:
        configdefsContents   = ""

    sucess = ''
    if configdefsContents != '' :

        # Set Domain
        #If this is not a pristine installation and Config Server has already modified this parameter, then the test will fail
        if configdefsContents.find('SIPXCHANGE_DOMAIN_NAME=`hostname -f`') > 0 :
            configdefsContents = configdefsContents.replace('SIPXCHANGE_DOMAIN_NAME=`hostname -f`', 'SIPXCHANGE_DOMAIN_NAME=%s',1) % SipDomain
            sucess = 'True'
        else :
            log_printout('Error: String SIPXCHANGE_DOMAIN_NAME=`hostname -f` not found in config.defs')
            log_printout('Error: This could be because this is not a pristine installation and sipXconfig already modified this setting,')

        # Set Realm
        if configdefsContents.find('SIPXCHANGE_REALM=`hostname -d`') > 0 :
            configdefsContents = configdefsContents.replace('SIPXCHANGE_REALM=`hostname -d`', 'SIPXCHANGE_REALM=%s',1) % SipDomain
            sucess = 'True'
        else :
            log_printout('Error: String SIPXCHANGE_REALM=`hostname -d` not found in config.defs')
            log_printout('Error: This could be because this is not a pristine installation and sipXconfig already modified this setting,')

        if sucess :
            file (CONFIGDEFSFile, 'w').write(configdefsContents)
        log_printout(CONFIGDEFSFile)
        log_printout(configdefsContents)

    else :
            log_printout('Error: config.defs file was empty or not found; file not changed')


def set_vsftp() :
    # tftp is configured by installing sipxconfig-tftp RPM
    # vsftp:  Password needs to be set because this failed during RPM install of sipxconfig-ftp on Live-CD

#    if LIVECD :
    if not useHASystem or useMasterHASystem :
        show_progress()
        log_printout ( '\n--- Configuring vsftp Service ---\n' )
        STARTSIPXCMD = 'echo -e "PlcmSpIp" | passwd --stdin PlcmSpIp'
        cmdoutput=commands.getoutput(STARTSIPXCMD)
        log_printout(cmdoutput)

        STARTSIPXCMD = 'service vsftpd start'
        cmdoutput=commands.getoutput(STARTSIPXCMD)
        log_printout(cmdoutput)
        log_printout('vsftp Server password changed and service started')
#    else :
        cmdoutput=commands.getoutput ('/sbin/chkconfig --level %d vsftp on' % RUNLEVEL)
        log_printout('vsftp Server enabled in runlevel')



def Distributed_OnlyServices () :

    if useHASystem and not useMasterHASystem :
        show_progress()

        xmlFiles = [ 'sipxcallresolver-agent.process.xml' ]

        for i in range(len(xmlFiles)) :
            FILE = PROCESS_D + xmlFiles[i]
            try:
                FileContents   = file (FILE).read().strip()

            except:
                FileContents   = ""

            if FileContents != "" :
                if FileContents.find('<watchdog-process enable=\"false\"') > 0 :
                    newContent = FileContents.replace('<watchdog-process enable=\"false\"', '<watchdog-process enable=\"true\"', 1)
                    file (FILE, 'w').write(newContent)
                    log_printout(FILE)
                    log_printout(newContent)

                    # Validate the modified file
                    cmdoutput=commands.getoutput ('sipx-validate-xml %s' % FILE) 
                    log_printout('File %s validated:\n' % FILE + cmdoutput)
                else :
                    log_printout('Error: Could not find string to be replaced in file: %s' % FILE)
            else :
                log_printout(FILE)
                log_printout('Error: Could not read file: %s' % FILE)
    else :
        log_printout('No HA or Distributed system selected - no action necessary')



def Distributed_NonReplicatedServices () :

    if useHASystem and not useMasterHASystem :
        show_progress()

        xmlFiles = [ 'sipstatus.process.xml', \
                     'sipxconfig.process.xml', \
                     'sipxpark.process.xml', \
                     'sipxpage.process.xml', \
                     'sipxpresence.process.xml', \
                     'sipXvxml.process.xml', \
                     'sipxrls.process.xml', \
                     'sipxcallresolver.process.xml', \
                     'sipxacd.process.xml' ]

        for i in range(len(xmlFiles)) :
            FILE = PROCESS_D + xmlFiles[i]
            try:
                FileContents   = file (FILE).read().strip()

            except:
                FileContents   = ""

            if FileContents != "" :
                if FileContents.find('<watchdog-process enable=\"true\"') > 0 :
                    newContent = FileContents.replace('<watchdog-process enable=\"true\"', '<watchdog-process enable=\"false\"', 1)
                    file (FILE, 'w').write(newContent)
                    log_printout(FILE)
                    log_printout(newContent)

                    # Validate the modified file
                    cmdoutput=commands.getoutput ('sipx-validate-xml %s' % FILE) 
                    log_printout('File %s validated:\n' % FILE + cmdoutput)
                else :
                    log_printout('Error: Could not find string to be replaced in file: %s' % FILE)
            else :
                log_printout(FILE)
                log_printout('Error: Could not read file: %s' % FILE)
    else :
        log_printout('No HA or Distributed system selected - no action necessary')


def set_DistributedConfigDefs () :
    # Configure routing for non-replicated services on the distributed server

    if useHASystem and not useMasterHASystem :

        show_progress()
        log_printout ( '\n--- Configure routing for non-replicated services on the distributed server ---\n' )

        addrRecords = ['CONFIG_SERVER_ADDR=${MY_IP_ADDR}', \
                       'CONFIG_SERVER_AGENT_ADDR=${MY_IP_ADDR}', \
                       'MEDIA_SERVER_ADDR=${MY_IP_ADDR}', \
                       'STATUS_SERVER_ADDR=${MY_IP_ADDR}', \
                       'VOICEMAIL_SERVER_ADDR=${MY_IP_ADDR}', \
                       'ORBIT_SERVER_ADDR=${MY_IP_ADDR}', \
                       'PRESENCE_SERVER_ADDR=${MY_IP_ADDR}', \
                       'CALLRESOLVER_AGENT_ADDR=${MY_IP_ADDR}', \
                       'PAGE_SERVER_ADDR=${MY_IP_ADDR}', \
                       'RLS_ADDR=${MY_IP_ADDR}' ]

        hostRecords = ['VOICEMAIL_SERVER_HOSTNAME=${MY_FULL_HOSTNAME}', \
                       'CONFIG_SERVER_HOST=${MY_FULL_HOSTNAME}' ]

        # Configure /etc/sipxpbx/config.defs
        try:
            configdefsContents   = file (CONFIGDEFSFile).read().strip()
        except:
            configdefsContents   = ""

        if configdefsContents != '' :

            # Edit lines whose value must be changed to the IP address of the master server
            for i in range(len(addrRecords)) :
                if configdefsContents.find(addrRecords[i]) > 0 :
                    oldLine=addrRecords[i]
                    configdefsContents = \
                        configdefsContents.replace(addrRecords[i], \
                                                   (addrRecords[i].split('='))[0] + '=%s' \
                                                   % DistributedIpAddress, 1)
                    # Just log the file name processed
                    log_printout('   replaced: "%s" -> "%s"' % (oldLine, DistributedIpAddress))
                else :
                    log_printout('Error: "%s" not found in config.defs' % addrRecords[i])
                    log_printout('This could be because this is not a pristine installation.')

            # Edit lines whose value must be changed to the master host name
            for i in range(len(hostRecords)) :
                if configdefsContents.find(hostRecords[i]) > 0 :
                    oldLine=hostRecords[i]
                    configdefsContents = \
                        configdefsContents.replace(hostRecords[i], \
                                                   (hostRecords[i].split('='))[0] + '=%s' \
                                                   % DistributedHostName, 1)
                    # Just log the file name processed
                    log_printout('   changed value: "%s" -> "%s"' % (oldLine, DistributedHostName))
                else :
                    log_printout('Error: "%s" not found in config.defs' % hostRecords[i])
                    log_printout('This could be because this is not a pristine installation.')

            file (CONFIGDEFSFile, 'w').write(configdefsContents)
            log_printout(configdefsContents)

        else :
                log_printout('Error: config.defs file was empty or not found; file not changed')
    else :
        log_printout('No HA or Master system selected - no action necessary')


def setMasterServerToManageDistributed () :

    # sipXconfig on the Master Servers needs to be configured to also managed services on the Distributed

    if useHASystem and useMasterHASystem :

        show_progress()
        log_printout ( '\n--- Configure Master to manage Distributed system ---\n' )

        records = [ '<!-- REMOVE THIS LINE TO ADD DISTRIBUTED SERVER', \
                    'REMOVE THIS LINE TO ADD DISTRIBUTED SERVER -->', \
                    'DISTRIBUTED_HOSTNAME', \
                    'DISTRIBUTED_HOSTNAME' ]
        replace = [ '', \
                    '', \
                    '%s' % DistributedHostName, \
                    '%s' % DistributedHostName ]

        # Configure /etc/sipxpbx/topology.xml.in

        try:
            topologyContents   = file (TOPOLOGYFILE).read().strip()
        except:
            topologyContents   = ""

        if topologyContents != '' :

            for i in range(len(records)) :
                if topologyContents.find(records[i]) > 0 :
                    topologyContents = topologyContents.replace(records[i], replace[i], 1)
                    # Just log the file name processed
                    log_printout(TOPOLOGYFILE)
                else :
                    log_printout('Error: %s not found in topology.xml.in' % records[i])
                    log_printout('This could be because this is not a pristine installation.')

            topologyContents += '\n'
            file (TOPOLOGYFILE, 'w').write(topologyContents)
            log_printout(topologyContents)

        else :
                log_printout('Error: topology.xml.in file was empty or not found; file not changed')
    else :
        log_printout('No HA or Distributed system selected - no action necessary')


def setRegistrySynchronization () :

    # Registrar on both systems needs to be configured to also synchronize with the other

    if useHASystem :

        show_progress()
        log_printout ( '\n--- Configure Registrar to Synchronize ---\n' )

        records = [ 'SIP_REGISTRAR_SYNC_WITH :' \
                  ]
        replace = [ 'SIP_REGISTRAR_SYNC_WITH : %s, %s' % ( HostName, DistributedHostName ) \
                  ]

        # Configure /etc/sipxpbx/registrar-config.in

        try:
            registrarContents   = file (REGISTRARFILE).read().strip()
        except:
            registrarContents   = ""

        if registrarContents != '' :

            for i in range(len(records)) :
                if registrarContents.find(records[i]) > 0 :
                    registrarContents = registrarContents.replace(records[i], replace[i], 1)
                    # Just log the file name processed
                    log_printout(REGISTRARFILE)
                else :
                    log_printout('Error: %s not found in registrar.config.in' % records[i])
                    log_printout('This could be because this is not a pristine installation.')

            registrarContents += '\n'       # Fix for EOF problem
            file (REGISTRARFILE, 'w').write(registrarContents)
            log_printout(registrarContents)

        else :
                log_printout('Error: registrar-config.in file was empty or not found; file not changed')
    else :
        log_printout('No HA system selected - no action necessary')


def setProxyRouting () :

    # Proxy on both systems needs to be configured to route services to the other

    if useHASystem :

        show_progress()
        log_printout ( '\n--- Configure Proxy Routing ---\n' )

        records = [ 'MASTER_HOSTNAME=', \
                    'DISTRIBUTED_HOSTNAME=', \
                    'REGISTRAR_SERVER_SIP_SRV_OR_HOSTPORT=${REGISTRAR_SERVER_ADDR}:${REGISTRAR_SERVER_SIP_PORT}' ]
        if useMasterHASystem :
            replace = [ 'MASTER_HOSTNAME=%s\n' % HostName, \
                        'DISTRIBUTED_HOSTNAME=%s\n' % DistributedHostName, \
                        'REGISTRAR_SERVER_SIP_SRV_OR_HOSTPORT=rr.${MY_FULL_HOSTNAME}\n' ]
        else :
            replace = [ 'MASTER_HOSTNAME=%s\n' % DistributedHostName, \
                        'DISTRIBUTED_HOSTNAME=%s\n' % HostName, \
                        'REGISTRAR_SERVER_SIP_SRV_OR_HOSTPORT=rr.${MY_FULL_HOSTNAME}\n' ]

        # Configure /etc/sipxpbx/config.defs

        try:
            configdefsContents   = file (CONFIGDEFSFile).read().strip()
        except:
            configdefsContents   = ""

        if configdefsContents != '' :

            for i in range(len(records)) :
                if configdefsContents.find(records[i]) > 0 :
                    configdefsContents = configdefsContents.replace(records[i], replace[i], 1)
                    # Just log the file name processed
                    log_printout(CONFIGDEFSFile)
                else :
                    log_printout('Error: %s not found in config.defs' % records[i])
                    log_printout('This could be because this is not a pristine installation.')

            file (CONFIGDEFSFile, 'w').write(configdefsContents)
            log_printout(configdefsContents)

        else :
                log_printout('Error: config.defs file was empty or not found; file not changed')
    else :
        log_printout('No HA system selected - no action necessary')


def setupHACDR () :
    # Configure the CallResolver to collect CSE's also from the Distributed

    if useHASystem and useMasterHASystem :
        # On the Master system add the Distributed CSE database to the callresolver-config.in file
        show_progress()
        log_printout ( '\n--- Configure HA Master CallResolver ---\n' )

        try:
            FileContents   = file (CDRCONFIG).read().strip()

        except:
            FileContents   = ''

        if FileContents != '' :
            FileContents += '\n'
            FileContents += 'SIP_CALLRESOLVER_CSE_HOSTS : localhost, %s:5433\n' % DistributedHostName
            FileContents += 'SIP_CALLRESOLVER_CSE_CA : ca.%s.crt\n' % HostName

            file (CDRCONFIG, 'w').write(FileContents)
            log_printout(CDRCONFIG)
            log_printout(FileContents)

        else :
            log_printout('Error: %s file was empty or not found; file not changed' % CDRCONFIG)
    
    else :
        log_printout('No HA system selected - no action necessary')


def removeInitScript () :

    rootInitFile='/root/.bashrc'
    initFileLines = file(rootInitFile).read().split('\n')

    # this must be carefully coordinated with the insertion of this in ks.cfg
    initScript=sre.compile('sipx_reset_cd')
    newInitFile = open(rootInitFile,'w')
    for line in initFileLines :
        if initScript.search(line):
            continue
        else:
            newInitFile.write("%s\n" % line)
    newInitFile.close


def setup_completed () :

    if LIVECD :
        log_printout ( '\n--- Exit to shell ---\n' )
        log_close()
        sys.exit()

    else :
        completedMessage ="\
All parameters have been configured. The configuration will take effect at the next reboot.\n\
\n\
When the system comes up after the reboot, open\n\
\n\
   http://%s\n\
\n\
in your web browser to begin configuring your PBX.\
" % HostName

        grid = snack.Grid(2, 1)

        rebootButton = snack.Button("Reboot")
        grid.setField(rebootButton, 0, 0, (1,0,1,1))

        shellButton = snack.Button("Exit to Prompt")
        grid.setField(shellButton, 1, 0, (1,0,1,1))

        form = screen_setup("Setup Completed", completedMessage, grid)
        choice = form.run()

        screen_end()
        screen.finish()

        if choice == rebootButton :
            #--- Rebooting the host
            log_printout ( '\n--- Rebooting the host ---\n' )
            time.sleep (1)
            cmdoutput=commands.getoutput  ('reboot')
            log_printout (cmdoutput)
            log_close()
        else :
            log_printout ( '\n--- Exit to shell ---\n' )
            log_close()

        sys.exit()


def fix_DNS_on_CentOS4 () :
    # On CentOS 4 rndc is misconfigured so that "service named status" results in an error
     try:
         osRelease   = file ('/etc/redhat-release').read().strip()
     except:
         osRelease   = ""

     log_printout ('Operating System: %s' % osRelease)
     if osRelease.find('CentOS release 4.4') == 0 :
         log_printout ( '\n--- Fixing rndc.conf for CentOS 4.4' )

         cmdoutput=commands.getoutput('mv /etc/rndc.conf /etc/rndc.conf.orig')
         log_printout(cmdoutput)

         cmdoutput=commands.getoutput('rndc-confgen -a')
         log_printout(cmdoutput)


def update_preLogonMessage () :
     # Update the message that displays on the console login screen

     logonMessage = '\n'
     logonMessage +='Welcome to your new VoIP system\n'
     logonMessage +='===============================\n'
     logonMessage +='\n'
     logonMessage +='Admin interface:\n'
     logonMessage +='Point a Browser at: http://%s\n' % HostName
     logonMessage +='                or: http://%s\n' % IpAddress
     logonMessage +='\n'

     log_printout("/etc/issue file written")
     log_printout(logonMessage)
     file ( "/etc/issue", 'a').write( logonMessage )



#======================================================================
# MAIN SCRIPT BODY STARTS HERE
#======================================================================

#--- Get command line arguments

log_init()
screen_init()

try:
    progress(0,"Check Prerequisites")
    check_prerequisites()

    removeInitScript()

    progress(3,"Start Wizard")
    screen_startup()

    progress(5,"Check HA System")
    screen_ask_HASystem ()

    while RedoAskServers == 0:
        RedoAskServers = 1

        progress(7,"Ask for Additional Services")
        screen_ask_services()

        progress(10, "Collect Network Settings")
        screen_ask_net()

        # Don't ask for Distributed networking parameters if the master settings failed
        # and will be re-done
        if useHASystem and RedoAskServers == 1 :
            progress(15, "Collect Redundant System Network Settings")
            screen_ask_net_Distributed ()

    progress(20, "Collect Administrator Settings")
    screen_ask_admin()

    progress(25, "Collect Time Settings")
    screen_get_tz()

    progress(30, "Collect SIP Domain Name Settings")
    screen_ask_sip()

    progress(35, "Collect Security Settings")
    screen_ask_ssl()

    progress(40, "Configure timezone")
    set_timezone()

    # must be after the timezone, should be the last interactive step
    progress(45, "Set system clock")
    screen_set_time()

    progress(50, "Configure administrator password")
    set_password()

    progress(55, "Configure administrator email")
    set_admin_mail()

    progress(60, "Configure hostname")
    set_network()

    progress(65, "Configure network interface")
    set_netif()

    progress(70, "Configure network time service")
    set_ntp()

    progress(72, "Configure DHCP Server")
    set_dhcpd ()

    progress(73, "Configure DNS Server")
    set_dns ()

    progress(75, "Set SIP Domainname and Realm")
    set_SIPDomain()

    progress(80, "Generate TLS/SSL Certificate")
    generate_ssl_cert()

    progress(85, "Install TLS/SSL Certificate")
    install_ssl_cert()

    progress(87, 'Configure Phone Configuration Access' )
    set_vsftp()    

    if useHASystem :

        progress(90, 'Configure Registrar Synchronization' )
        setRegistrySynchronization ()

        progress(91, 'Configure Proxy Routing' )
        setProxyRouting ()

        if useMasterHASystem :
            progress(92, 'Configure Master to manage Distributed' )
            setMasterServerToManageDistributed ()

        else :
            progress(92, 'Turning on services unique to a Distributed server' )
            Distributed_OnlyServices ()

            progress(93, 'Turning off non-replicated services on the Distributed server' )
            Distributed_NonReplicatedServices ()

            progress(94, 'Configure routing for non-replicated services on the distributed server' )
            set_DistributedConfigDefs ()

            progress(95,"Check Installed Distributed Certificate")
            test_for_installed_Distributed_Certificate ()

        # After installing the certificate, as the cert is required to initialize stunnel
        progress(96, 'Configure HA CallResolver' )
        setupHACDR ()

    # Modify console logon message
    update_preLogonMessage ()

    # Generate host specific X11 configuration
    set_xorg_conf ()

    progress(98, 'Starting sipX...' )
    #Start sipX
    if LIVECD :
        STARTSIPXCMD = 'bash service sipxpbx start &'
        # cmdoutput=commands.getoutput(STARTSIPXCMD)
        # log_printout(cmdoutput)
        os.system(STARTSIPXCMD)
    else :
        cmdoutput=commands.getoutput ('/sbin/chkconfig --level %d sipxpbx on' % RUNLEVEL)
        log_printout('sipxpbx service enabled in runlevel')
        cmdoutput=commands.getoutput ('/sbin/chkconfig --level %d postgresql on' % RUNLEVEL)
        log_printout('postgresql service enabled in runlevel')

    #Start X11
    if LIVECD :
        STARTXCMD = 'bash startxfce4 &'
        # cmdoutput=commands.getoutput(STARTXCMD)
        # log_printout(cmdoutput)
        os.system(STARTXCMD)

    progress(100, 'Ready')
    setup_completed()
    # setup_completed does not return

except:

    excType, excData, excTrace = sys.exc_info()
    if   excType == KeyboardInterrupt:
        log_printout ( '\n\n*** User Interrupt Detected ***\n\n' )
    elif excType == SystemExit:
        log_printout ( '\n%s\n' % str (excData) )
    else:
        errStack = traceback.extract_tb(excTrace)[-1]
        errMsg   = '\nUNEXPECTED EXCEPTION CAPTURED:\n\n'
        errMsg  += '%s: %s ' % (str(excType), str(excData))
        errMsg  += '(exception occured in file: %s, line: %s)\n' % (errStack[0], errStack[1])
        log_printout ( errMsg )
    screen.finish()
    log_close()

